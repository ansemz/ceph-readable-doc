
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>归置组排障 &#8212; Ceph Documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/ceph.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" />
    <link rel="next" title="日志记录和调试" href="../log-and-debug/" />
    <link rel="prev" title="OSD 故障排除" href="../troubleshooting-osd/" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../log-and-debug/" title="日志记录和调试"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../troubleshooting-osd/" title="OSD 故障排除"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">Ceph Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" >Ceph 存储集群</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../operations/" accesskey="U">集群运维</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            

<div id="dev-warning" class="admonition note" style="display:none;">
  <p class="first admonition-title">Notice</p>
  <p class="last">This document is for a development version of Ceph.</p>
</div>

<div id="eol-warning" class="admonition warning" style="display:none;">
  <p class="first admonition-title">Warning</p>
  <p class="last">This document is for an unsupported version of Ceph.</p>
</div>
  <div id="docubetter" align="right" style="display:none; padding: 15px; font-weight: bold;">
    <a id="edit-on-github" href="https://github.com/ceph/ceph/edit/master/doc/rados/troubleshooting/troubleshooting-pg.rst" rel="nofollow">Edit on GitHub</a> | <a href="https://pad.ceph.com/p/Report_Documentation_Bugs">Report a Documentation Bug</a>
  </div>

  
  <div class="section" id="id1">
<h1>归置组排障<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>归置组总不整洁<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>When you create a cluster and your cluster remains in <code class="docutils literal notranslate"><span class="pre">active</span></code>,
<code class="docutils literal notranslate"><span class="pre">active+remapped</span></code> or <code class="docutils literal notranslate"><span class="pre">active+degraded</span></code> status and never achieve an
<code class="docutils literal notranslate"><span class="pre">active+clean</span></code> status, you likely have a problem with your configuration.</p>
<p>You may need to review settings in the <a class="reference external" href="../../configuration/pool-pg-config-ref">存储池、归置组和 CRUSH 配置参考</a>
and make appropriate adjustments.</p>
<p>As a general rule, you should run your cluster with more than one OSD and a
pool size greater than 1 object replica.</p>
<div class="section" id="id3">
<h3>单节点集群<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Ceph no longer provides documentation for operating on a single node, because
you would never deploy a system designed for distributed computing on a single
node. Additionally, mounting client kernel modules on a single node containing a
Ceph  daemon may cause a deadlock due to issues with the Linux kernel itself
(unless you use VMs for the clients). You can experiment with Ceph in a 1-node
configuration, in spite of the limitations as described herein.</p>
<p>If you are trying to create a cluster on a single node, you must change the
default of the <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">crush</span> <span class="pre">chooseleaf</span> <span class="pre">type</span></code> setting from <code class="docutils literal notranslate"><span class="pre">1</span></code> (meaning
<code class="docutils literal notranslate"><span class="pre">host</span></code> or <code class="docutils literal notranslate"><span class="pre">node</span></code>) to <code class="docutils literal notranslate"><span class="pre">0</span></code> (meaning <code class="docutils literal notranslate"><span class="pre">osd</span></code>) in your Ceph configuration
file before you create your monitors and OSDs. This tells Ceph that an OSD
can peer with another OSD on the same host. If you are trying to set up a
1-node cluster and <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">crush</span> <span class="pre">chooseleaf</span> <span class="pre">type</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">0</span></code>,
Ceph will try to peer the PGs of one OSD with the PGs of another OSD on
another node, chassis, rack, row, or even datacenter depending on the setting.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>DO NOT mount kernel clients directly on the same node as your
Ceph Storage Cluster, because kernel conflicts can arise. However, you
can mount kernel clients within virtual machines (VMs) on a single node.</p>
</div>
<p>If you are creating OSDs using a single disk, you must create directories
for the data manually first. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span><span class="o">-</span><span class="n">deploy</span> <span class="n">osd</span> <span class="n">create</span> <span class="o">--</span><span class="n">data</span> <span class="p">{</span><span class="n">disk</span><span class="p">}</span> <span class="p">{</span><span class="n">host</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="osd">
<h3>OSD 数量小于副本数<a class="headerlink" href="#osd" title="Permalink to this headline">¶</a></h3>
<p>If you’ve brought up two OSDs to an <code class="docutils literal notranslate"><span class="pre">up</span></code> and <code class="docutils literal notranslate"><span class="pre">in</span></code> state, but you still
don’t see <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">+</span> <span class="pre">clean</span></code> placement groups, you may have an
<code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">pool</span> <span class="pre">default</span> <span class="pre">size</span></code> set to greater than <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<p>There are a few ways to address this situation. If you want to operate your
cluster in an <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">+</span> <span class="pre">degraded</span></code> state with two replicas, you can set the
<code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">pool</span> <span class="pre">default</span> <span class="pre">min</span> <span class="pre">size</span></code> to <code class="docutils literal notranslate"><span class="pre">2</span></code> so that you can write objects in
an <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">+</span> <span class="pre">degraded</span></code> state. You may also set the <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">pool</span> <span class="pre">default</span> <span class="pre">size</span></code>
setting to <code class="docutils literal notranslate"><span class="pre">2</span></code> so that you only have two stored replicas (the original and
one replica), in which case the cluster should achieve an <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">+</span> <span class="pre">clean</span></code>
state.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can make the changes at runtime. If you make the changes in
your Ceph configuration file, you may need to restart your cluster.</p>
</div>
</div>
<div class="section" id="id4">
<h3>存储池副本数为 1<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>If you have the <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">pool</span> <span class="pre">default</span> <span class="pre">size</span></code> set to <code class="docutils literal notranslate"><span class="pre">1</span></code>, you will only have
one copy of the object. OSDs rely on other OSDs to tell them which objects
they should have. If a first OSD has a copy of an object and there is no
second copy, then no second OSD can tell the first OSD that it should have
that copy. For each placement group mapped to the first OSD (see
<code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">pg</span> <span class="pre">dump</span></code>), you can force the first OSD to notice the placement groups
it needs by running:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">force</span><span class="o">-</span><span class="n">create</span><span class="o">-</span><span class="n">pg</span> <span class="o">&lt;</span><span class="n">pgid</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="crush">
<h3>CRUSH 图错误<a class="headerlink" href="#crush" title="Permalink to this headline">¶</a></h3>
<p>Another candidate for placement groups remaining unclean involves errors
in your CRUSH map.</p>
</div>
</div>
<div class="section" id="id5">
<h2>卡住的归置组<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>有失败时归置组会进入“degraded”（降级）或“peering”（连接建立中）状态，这事时有发生，通常这些状态意味着正常的失败恢复正在进行。然而，如果一个归置组长时间处于某个这些状态就意味着有更大的问题，因此监视器在归置组卡 （stuck） 在非最优状态时会警告。我们具体检查：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">inactive</span></code> （不活跃）——归置组长时间无活跃（即它不能提供读写服务了）；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">unclean</span></code> （不干净）——归置组长时间不干净（例如它未能从前面的失败完全恢复）；</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stale</span></code> （不新鲜）——归置组状态没有被 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 更新，表明存储这个归置组的所有节点可能都挂了。</p></li>
</ul>
<p>你可以摆出卡住的归置组：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="n">dump_stuck</span> <span class="n">stale</span>
<span class="n">ceph</span> <span class="n">pg</span> <span class="n">dump_stuck</span> <span class="n">inactive</span>
<span class="n">ceph</span> <span class="n">pg</span> <span class="n">dump_stuck</span> <span class="n">unclean</span>
</pre></div>
</div>
<p>卡在 <code class="docutils literal notranslate"><span class="pre">stale</span></code> 状态的归置组通过修复 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 进程通常可以修复；卡在 <code class="docutils literal notranslate"><span class="pre">inactive</span></code> 状态的归置组通常是互联问题（参见 <a class="reference internal" href="#failures-osd-peering"><span class="std std-ref">归置组挂了——互联失败</span></a> ）；卡在 <code class="docutils literal notranslate"><span class="pre">unclean</span></code> 状态的归置组通常是由于某些原因阻止了恢复的完成，像未找到的对象（参见 <a class="reference internal" href="#failures-osd-unfound"><span class="std std-ref">未找到的对象</span></a> ）。</p>
</div>
<div class="section" id="failures-osd-peering">
<span id="id6"></span><h2>归置组挂了——互联失败<a class="headerlink" href="#failures-osd-peering" title="Permalink to this headline">¶</a></h2>
<p>在某些情况下， <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 连接建立进程会遇到问题，使 PG 不能活跃、可用，例如 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span></code> 也许显示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">health</span> <span class="n">detail</span>
<span class="n">HEALTH_ERR</span> <span class="mi">7</span> <span class="n">pgs</span> <span class="n">degraded</span><span class="p">;</span> <span class="mi">12</span> <span class="n">pgs</span> <span class="n">down</span><span class="p">;</span> <span class="mi">12</span> <span class="n">pgs</span> <span class="n">peering</span><span class="p">;</span> <span class="mi">1</span> <span class="n">pgs</span> <span class="n">recovering</span><span class="p">;</span> <span class="mi">6</span> <span class="n">pgs</span> <span class="n">stuck</span> <span class="n">unclean</span><span class="p">;</span> <span class="mi">114</span><span class="o">/</span><span class="mi">3300</span> <span class="n">degraded</span> <span class="p">(</span><span class="mf">3.455</span><span class="o">%</span><span class="p">);</span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span> <span class="ow">in</span> <span class="n">osds</span> <span class="n">are</span> <span class="n">down</span>
<span class="o">...</span>
<span class="n">pg</span> <span class="mf">0.5</span> <span class="ow">is</span> <span class="n">down</span><span class="o">+</span><span class="n">peering</span>
<span class="n">pg</span> <span class="mf">1.4</span> <span class="ow">is</span> <span class="n">down</span><span class="o">+</span><span class="n">peering</span>
<span class="o">...</span>
<span class="n">osd</span><span class="o">.</span><span class="mi">1</span> <span class="ow">is</span> <span class="n">down</span> <span class="n">since</span> <span class="n">epoch</span> <span class="mi">69</span><span class="p">,</span> <span class="n">last</span> <span class="n">address</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">106.220</span><span class="p">:</span><span class="mi">6801</span><span class="o">/</span><span class="mi">8651</span>
</pre></div>
</div>
<p>可以查询到 PG 为何被标记为 <code class="docutils literal notranslate"><span class="pre">down</span></code> ：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="mf">0.5</span> <span class="n">query</span>
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="s2">&quot;state&quot;</span><span class="o">:</span> <span class="s2">&quot;down+peering&quot;</span><span class="p">,</span>
  <span class="p">...</span>
  <span class="s2">&quot;recovery_state&quot;</span><span class="o">:</span> <span class="p">[</span>
       <span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;Started\/Primary\/Peering\/GetInfo&quot;</span><span class="p">,</span>
         <span class="s2">&quot;enter_time&quot;</span><span class="o">:</span> <span class="s2">&quot;2012-03-06 14:40:16.169679&quot;</span><span class="p">,</span>
         <span class="s2">&quot;requested_info_from&quot;</span><span class="o">:</span> <span class="p">[]},</span>
       <span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;Started\/Primary\/Peering&quot;</span><span class="p">,</span>
         <span class="s2">&quot;enter_time&quot;</span><span class="o">:</span> <span class="s2">&quot;2012-03-06 14:40:16.169659&quot;</span><span class="p">,</span>
         <span class="s2">&quot;probing_osds&quot;</span><span class="o">:</span> <span class="p">[</span>
               <span class="mi">0</span><span class="p">,</span>
               <span class="mi">1</span><span class="p">],</span>
         <span class="s2">&quot;blocked&quot;</span><span class="o">:</span> <span class="s2">&quot;peering is blocked due to down osds&quot;</span><span class="p">,</span>
         <span class="s2">&quot;down_osds_we_would_probe&quot;</span><span class="o">:</span> <span class="p">[</span>
               <span class="mi">1</span><span class="p">],</span>
         <span class="s2">&quot;peering_blocked_by&quot;</span><span class="o">:</span> <span class="p">[</span>
               <span class="p">{</span> <span class="s2">&quot;osd&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="s2">&quot;current_lost_at&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
                 <span class="s2">&quot;comment&quot;</span><span class="o">:</span> <span class="s2">&quot;starting or marking this osd lost may let us proceed&quot;</span><span class="p">}]},</span>
       <span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;Started&quot;</span><span class="p">,</span>
         <span class="s2">&quot;enter_time&quot;</span><span class="o">:</span> <span class="s2">&quot;2012-03-06 14:40:16.169513&quot;</span><span class="p">}</span>
   <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">recovery_state</span></code> 段告诉我们连接建立因 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 进程挂了而被阻塞，本例是 <code class="docutils literal notranslate"><span class="pre">osd.1</span></code> 挂了，启动这个进程应该就可以恢复。</p>
<p>另外，如果 <code class="docutils literal notranslate"><span class="pre">osd.1</span></code> 是灾难性的失败（如硬盘损坏），我们可以告诉集群它丢失（ <code class="docutils literal notranslate"><span class="pre">lost</span></code> ）了，让集群尽力完成副本拷贝。</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>集群不能保证其它数据副本是一致且最新就危险了！</p>
</div>
<p>让 Ceph 无论如何都继续：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">lost</span> <span class="mi">1</span>
</pre></div>
</div>
<p>恢复将继续。</p>
</div>
<div class="section" id="failures-osd-unfound">
<span id="id7"></span><h2>未找到的对象<a class="headerlink" href="#failures-osd-unfound" title="Permalink to this headline">¶</a></h2>
<p>某几种失败相组合可能导致 Ceph 抱怨有找不到（ <code class="docutils literal notranslate"><span class="pre">unfound</span></code> ）的对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">health</span> <span class="n">detail</span>
<span class="n">HEALTH_WARN</span> <span class="mi">1</span> <span class="n">pgs</span> <span class="n">degraded</span><span class="p">;</span> <span class="mi">78</span><span class="o">/</span><span class="mi">3778</span> <span class="n">unfound</span> <span class="p">(</span><span class="mf">2.065</span><span class="o">%</span><span class="p">)</span>
<span class="n">pg</span> <span class="mf">2.4</span> <span class="ow">is</span> <span class="n">active</span><span class="o">+</span><span class="n">degraded</span><span class="p">,</span> <span class="mi">78</span> <span class="n">unfound</span>
</pre></div>
</div>
<p>这意味着存储集群知道一些对象（或者存在对象的较新副本）存在，却没有找到它们的副本。下例展示了这种情况是如何发生的，一个 PG
的数据存储在 ceph-osd 1 和 2 上：</p>
<ul class="simple">
<li><p>1 挂了；</p></li>
<li><p>2 独自处理一些写动作；</p></li>
<li><p>1 起来了；</p></li>
<li><p>1 和 2 重新互联， 1 上面丢失的对象加入队列准备恢复；</p></li>
<li><p>新对象还未拷贝完， 2 挂了。</p></li>
</ul>
<p>这时， 1 知道这些对象存在，但是活着的 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 都没有副本，这种情况下，读写这些对象的 IO 就会被阻塞，集群只能指望节点早点恢复。这时我们假设用户希望先得到一个 IO 错误。</p>
<p>首先，你应该确认哪些对象找不到了：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="mf">2.4</span> <span class="n">list_unfound</span> <span class="p">[</span><span class="n">starting</span> <span class="n">offset</span><span class="p">,</span> <span class="ow">in</span> <span class="n">json</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="s2">&quot;offset&quot;</span><span class="o">:</span> <span class="p">{</span> <span class="s2">&quot;oid&quot;</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
     <span class="s2">&quot;key&quot;</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
     <span class="s2">&quot;snapid&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s2">&quot;hash&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
     <span class="s2">&quot;max&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">},</span>
 <span class="s2">&quot;num_missing&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
 <span class="s2">&quot;num_unfound&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
 <span class="s2">&quot;objects&quot;</span><span class="o">:</span> <span class="p">[</span>
    <span class="p">{</span> <span class="s2">&quot;oid&quot;</span><span class="o">:</span> <span class="s2">&quot;object 1&quot;</span><span class="p">,</span>
      <span class="s2">&quot;key&quot;</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
      <span class="s2">&quot;hash&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
      <span class="s2">&quot;max&quot;</span><span class="o">:</span> <span class="mi">0</span> <span class="p">},</span>
    <span class="p">...</span>
 <span class="p">],</span>
 <span class="s2">&quot;more&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>如果在一次查询里列出的对象太多， <code class="docutils literal notranslate"><span class="pre">more</span></code> 这个字段将为
<code class="docutils literal notranslate"><span class="pre">true</span></code> ，因此你可以查询更多。（命令行工具可能隐藏了，但这里没有）</p>
<p>其次，你可以找出哪些 OSD 上探测到、或可能包含数据：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="mf">2.4</span> <span class="n">query</span>
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;recovery_state&quot;</span><span class="o">:</span> <span class="p">[</span>
     <span class="p">{</span> <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;Started\/Primary\/Active&quot;</span><span class="p">,</span>
       <span class="s2">&quot;enter_time&quot;</span><span class="o">:</span> <span class="s2">&quot;2012-03-06 15:15:46.713212&quot;</span><span class="p">,</span>
       <span class="s2">&quot;might_have_unfound&quot;</span><span class="o">:</span> <span class="p">[</span>
             <span class="p">{</span> <span class="s2">&quot;osd&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
               <span class="s2">&quot;status&quot;</span><span class="o">:</span> <span class="s2">&quot;osd is down&quot;</span><span class="p">}]},</span>
</pre></div>
</div>
<p>本例中，集群知道 <code class="docutils literal notranslate"><span class="pre">osd.1</span></code> 可能有数据，但它挂了（ <code class="docutils literal notranslate"><span class="pre">down</span></code> ）。所有可能的状态有：</p>
<ul class="simple">
<li><p>已经探测到了</p></li>
<li><p>在查询</p></li>
<li><p>OSD 挂了</p></li>
<li><p>尚未查询</p></li>
</ul>
<p>有时候集群要花一些时间来查询可能的位置。</p>
<p>还有一种可能性，对象存在于其它位置却未被列出，例如，集群里的一个 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 停止且被剔出，然后完全恢复了；后来的失败、恢复后仍有未找到的对象，它也不会觉得早已死亡的 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 上仍可能包含这些对象。（这种情况几乎不太可能发生）。</p>
<p>如果所有位置都查询过了仍有对象丢失，那就得放弃丢失的对象了。这仍可能是罕见的失败组合导致的，集群在写入完成前，未能得知写入是否已执行。以下命令把未找到的（ unfound ）对象标记为丢失（ lost ）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="mf">2.5</span> <span class="n">mark_unfound_lost</span> <span class="n">revert</span><span class="o">|</span><span class="n">delete</span>
</pre></div>
</div>
<p>上述最后一个参数告诉集群应如何处理丢失的对象。</p>
<p>delete 选项将导致完全删除它们。</p>
<p>revert 选项（纠删码存储池不可用）会回滚到前一个版本或者（如果它是新对象的话）删除它。要慎用，它可能迷惑那些期望对象存在的应用程序。</p>
</div>
<div class="section" id="id8">
<h2>无根归置组<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>拥有归置组拷贝的 OSD 都可以失败，在这种情况下，那一部分的对象存储不可用，监视器就不会收到那些归置组的状态更新了。为检测这种情况，监视器把任何主 OSD 失败的归置组标记为 <code class="docutils literal notranslate"><span class="pre">stale</span></code> （不新鲜），例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">health</span>
<span class="n">HEALTH_WARN</span> <span class="mi">24</span> <span class="n">pgs</span> <span class="n">stale</span><span class="p">;</span> <span class="mi">3</span><span class="o">/</span><span class="mi">300</span> <span class="ow">in</span> <span class="n">osds</span> <span class="n">are</span> <span class="n">down</span>
</pre></div>
</div>
<p>你能找出哪些归置组 <code class="docutils literal notranslate"><span class="pre">stale</span></code> 、和存储这些归置组的最新 OSD ，命令如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">health</span> <span class="n">detail</span>
<span class="n">HEALTH_WARN</span> <span class="mi">24</span> <span class="n">pgs</span> <span class="n">stale</span><span class="p">;</span> <span class="mi">3</span><span class="o">/</span><span class="mi">300</span> <span class="ow">in</span> <span class="n">osds</span> <span class="n">are</span> <span class="n">down</span>
<span class="o">...</span>
<span class="n">pg</span> <span class="mf">2.5</span> <span class="ow">is</span> <span class="n">stuck</span> <span class="n">stale</span><span class="o">+</span><span class="n">active</span><span class="o">+</span><span class="n">remapped</span><span class="p">,</span> <span class="n">last</span> <span class="n">acting</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="o">...</span>
<span class="n">osd</span><span class="o">.</span><span class="mi">10</span> <span class="ow">is</span> <span class="n">down</span> <span class="n">since</span> <span class="n">epoch</span> <span class="mi">23</span><span class="p">,</span> <span class="n">last</span> <span class="n">address</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">106.220</span><span class="p">:</span><span class="mi">6800</span><span class="o">/</span><span class="mi">11080</span>
<span class="n">osd</span><span class="o">.</span><span class="mi">11</span> <span class="ow">is</span> <span class="n">down</span> <span class="n">since</span> <span class="n">epoch</span> <span class="mi">13</span><span class="p">,</span> <span class="n">last</span> <span class="n">address</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">106.220</span><span class="p">:</span><span class="mi">6803</span><span class="o">/</span><span class="mi">11539</span>
<span class="n">osd</span><span class="o">.</span><span class="mi">12</span> <span class="ow">is</span> <span class="n">down</span> <span class="n">since</span> <span class="n">epoch</span> <span class="mi">24</span><span class="p">,</span> <span class="n">last</span> <span class="n">address</span> <span class="mf">192.168</span><span class="o">.</span><span class="mf">106.220</span><span class="p">:</span><span class="mi">6806</span><span class="o">/</span><span class="mi">11861</span>
</pre></div>
</div>
<p>如果想使归置组 2.5 重新在线，例如，上面的输出告诉我们它最后由 <code class="docutils literal notranslate"><span class="pre">osd.0</span></code> 和 <code class="docutils literal notranslate"><span class="pre">osd.2</span></code> 处理，重启这些 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 将恢复之（还有其它的很多 PG ）。</p>
</div>
<div class="section" id="id9">
<h2>只有几个 OSD 接收数据<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>如果你的集群有很多节点，但只有其中几个接收数据，<a class="reference external" href="../../operations/placement-groups#get-the-number-of-placement-groups">检查</a>下存储池里的归置组数量。因为归置组是映射到多个 OSD 的，这样少量的归置组将不能分布于整个集群。试着创建个新存储池，其归置组数量是 OSD 数量的若干倍。详情见<a class="reference external" href="../../operations/placement-groups">归置组</a>，存储池的默认归置组数量没多大用，你可以参考<a class="reference external" href="../../configuration/pool-pg-config-ref">这里</a>更改它。</p>
</div>
<div class="section" id="id10">
<h2>不能写入数据<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>如果你的集群已启动，但一些 OSD 没起来，导致不能写入数据，确认下运行的 OSD 数量满足归置组要求的最低 OSD 数。如果不能满足， Ceph 就不会允许你写入数据，因为 Ceph 不能保证复制能如愿进行。详情参见<a class="reference external" href="../../configuration/pool-pg-config-ref">存储池、归置组和 CRUSH 配置参考</a>里的 <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">pool</span> <span class="pre">default</span> <span class="pre">min</span> <span class="pre">size</span></code> 。</p>
</div>
<div class="section" id="id11">
<h2>归置组不一致<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<p>如果你看到状态变成了 <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">+</span> <span class="pre">clean</span> <span class="pre">+</span> <span class="pre">inconsistent</span></code> ，可能是洗刷时遇到了错误。与往常一样，我们可以这样找出不一致的归置组：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ceph health detail
HEALTH_ERR 1 pgs inconsistent; 2 scrub errors
pg 0.6 is active+clean+inconsistent, acting [0,1,2]
2 scrub errors
</pre></div>
</div>
<p>或者这样，如果你喜欢程序化的输出：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ rados list-inconsistent-pg rbd
[&quot;0.6&quot;]
</pre></div>
</div>
<p>一致的状态只有一种，然而在最坏的情况下，我们可能会遇到多个对象产生了各种各样的不一致。假设在 PG <code class="docutils literal notranslate"><span class="pre">0.6</span></code> 里的一个名为 <code class="docutils literal notranslate"><span class="pre">foo</span></code>
的对象被截断了，我们可以这样查看：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ rados list-inconsistent-obj 0.6 --format=json-pretty
</pre></div>
</div>
<div class="highlight-javascript notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;epoch&quot;</span><span class="o">:</span> <span class="mi">14</span><span class="p">,</span>
    <span class="s2">&quot;inconsistents&quot;</span><span class="o">:</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;object&quot;</span><span class="o">:</span> <span class="p">{</span>
                <span class="s2">&quot;name&quot;</span><span class="o">:</span> <span class="s2">&quot;foo&quot;</span><span class="p">,</span>
                <span class="s2">&quot;nspace&quot;</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;locator&quot;</span><span class="o">:</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="s2">&quot;snap&quot;</span><span class="o">:</span> <span class="s2">&quot;head&quot;</span><span class="p">,</span>
                <span class="s2">&quot;version&quot;</span><span class="o">:</span> <span class="mi">1</span>
            <span class="p">},</span>
            <span class="s2">&quot;errors&quot;</span><span class="o">:</span> <span class="p">[</span>
                <span class="s2">&quot;data_digest_mismatch&quot;</span><span class="p">,</span>
                <span class="s2">&quot;size_mismatch&quot;</span>
            <span class="p">],</span>
            <span class="s2">&quot;union_shard_errors&quot;</span><span class="o">:</span> <span class="p">[</span>
                <span class="s2">&quot;data_digest_mismatch_info&quot;</span><span class="p">,</span>
                <span class="s2">&quot;size_mismatch_info&quot;</span>
            <span class="p">],</span>
            <span class="s2">&quot;selected_object_info&quot;</span><span class="o">:</span> <span class="s2">&quot;0:602f83fe:::foo:head(16&#39;1 client.4110.0:1 dirty|data_digest|omap_digest s 968 uv 1 dd e978e67f od ffffffff alloc_hint [0 0 0])&quot;</span><span class="p">,</span>
            <span class="s2">&quot;shards&quot;</span><span class="o">:</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;osd&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;errors&quot;</span><span class="o">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;size&quot;</span><span class="o">:</span> <span class="mi">968</span><span class="p">,</span>
                    <span class="s2">&quot;omap_digest&quot;</span><span class="o">:</span> <span class="s2">&quot;0xffffffff&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;data_digest&quot;</span><span class="o">:</span> <span class="s2">&quot;0xe978e67f&quot;</span>
                <span class="p">},</span>
                <span class="p">{</span>
                    <span class="s2">&quot;osd&quot;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;errors&quot;</span><span class="o">:</span> <span class="p">[],</span>
                    <span class="s2">&quot;size&quot;</span><span class="o">:</span> <span class="mi">968</span><span class="p">,</span>
                    <span class="s2">&quot;omap_digest&quot;</span><span class="o">:</span> <span class="s2">&quot;0xffffffff&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;data_digest&quot;</span><span class="o">:</span> <span class="s2">&quot;0xe978e67f&quot;</span>
                <span class="p">},</span>
                <span class="p">{</span>
                    <span class="s2">&quot;osd&quot;</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;errors&quot;</span><span class="o">:</span> <span class="p">[</span>
                        <span class="s2">&quot;data_digest_mismatch_info&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;size_mismatch_info&quot;</span>
                    <span class="p">],</span>
                    <span class="s2">&quot;size&quot;</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;omap_digest&quot;</span><span class="o">:</span> <span class="s2">&quot;0xffffffff&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;data_digest&quot;</span><span class="o">:</span> <span class="s2">&quot;0xffffffff&quot;</span>
                <span class="p">}</span>

        <span class="p">}</span>
    <span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>此时，我们可以从输出里看到：</p>
<ul class="simple">
<li><p>唯一不一致的对象名为 <code class="docutils literal notranslate"><span class="pre">foo</span></code> ，并且它的 head 不一致。</p></li>
<li><p>不一致分为两类：</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">errors</span></code>: 这些错误表明不一致性出现在分片之间，但是没说明哪个（或哪些）分片有问题。如果 <cite>shards</cite> 阵列中有 <code class="docutils literal notranslate"><span class="pre">errors</span></code>
字段，且不为空，它会指出问题所在。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">data_digest_mismatch</span></code>: OSD.2 内读取到的副本的数字摘要与 OSD.0 和 OSD.1 的不一样。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_mismatch</span></code>: OSD.2 内读取到的副本的尺寸是 0 ，而
OSD.0 和 OSD.1 说是 968 。</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">union_shard_errors</span></code>: <code class="docutils literal notranslate"><span class="pre">shards</span></code> 阵列中、所有与分片相关的错误 <code class="docutils literal notranslate"><span class="pre">errors</span></code> 的并集。 <code class="docutils literal notranslate"><span class="pre">errors</span></code> 是个错误原因集合，汇集了相关分片的这类问题，如 <code class="docutils literal notranslate"><span class="pre">read_error</span></code> 。以 <code class="docutils literal notranslate"><span class="pre">oi</span></code> 结尾的 <code class="docutils literal notranslate"><span class="pre">errors</span></code> 表明它是与 <code class="docutils literal notranslate"><span class="pre">selected_object_info</span></code> 的对照结果。从 <code class="docutils literal notranslate"><span class="pre">shards</span></code> 阵列里可以查到哪个分片有什么样的错误。</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">data_digest_mismatch_info</span></code>: 存储在 object-info （
对象信息）里的数字签名不是 <code class="docutils literal notranslate"><span class="pre">0xffffffff</span></code> （这个是根据
OSD.2 上的分片计算出来的）。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">size_mismatch_info</span></code>: object-info 内存储的尺寸与 OSD.2
上的对象尺寸 0 不同。</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>你可以用下列命令修复不一致的归置组：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="n">repair</span> <span class="p">{</span><span class="n">placement</span><span class="o">-</span><span class="n">group</span><span class="o">-</span><span class="n">ID</span><span class="p">}</span>
</pre></div>
</div>
<p>此命令会用<cite>权威的</cite>副本覆盖<cite>有问题的</cite>。根据既定规则，多数情况下 Ceph 都能从若干副本中选择正确的，但是也会有例外。比如，存储的数字签名可能正好丢了，选择权威副本时又忽略了计算出的数字签名，总之，用此命令时小心为好。</p>
<p>如果一个分片的 <code class="docutils literal notranslate"><span class="pre">errors</span></code> 里出现了 <code class="docutils literal notranslate"><span class="pre">read_error</span></code> ，很可能是磁盘错误引起的不一致，你最好先查验那个 OSD 所用的磁盘。</p>
<p>如果你时不时遇到时钟偏移引起的 <code class="docutils literal notranslate"><span class="pre">active</span> <span class="pre">+</span> <span class="pre">clean</span> <span class="pre">+</span> <span class="pre">inconsistent</span></code>
状态，最好在监视器主机上配置 peer 角色的 <a class="reference external" href="https://en.wikipedia.org/wiki/Network_Time_Protocol">NTP</a> 服务。配置细节可参考<a class="reference external" href="http://www.ntp.org/">网络时间协议</a>和 Ceph <a class="reference external" href="../../configuration/mon-config-ref/#clock">时钟选项</a>。</p>
</div>
<div class="section" id="active-clean">
<h2>纠删编码的归置组不是 active+clean<a class="headerlink" href="#active-clean" title="Permalink to this headline">¶</a></h2>
<p>CRUSH 找不到足够多的 OSD 映射到某个 PG 时，它会显示为
<code class="docutils literal notranslate"><span class="pre">2147483647</span></code> ，意思是 ITEM_NONE 或 <code class="docutils literal notranslate"><span class="pre">no</span> <span class="pre">OSD</span> <span class="pre">found</span></code> ，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2147483647</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="id12">
<h3>OSD 不够多<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>如果 Ceph 集群仅有 8 个 OSD ，但是纠删码存储池需要 9 个，就会显示上面的错误。这时候，你仍然可以另外创建需要较少 OSD 的纠删码存储池：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">erasure</span><span class="o">-</span><span class="n">code</span><span class="o">-</span><span class="n">profile</span> <span class="nb">set</span> <span class="n">myprofile</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span> <span class="n">m</span><span class="o">=</span><span class="mi">3</span>
<span class="n">ceph</span> <span class="n">osd</span> <span class="n">pool</span> <span class="n">create</span> <span class="n">erasurepool</span> <span class="mi">16</span> <span class="mi">16</span> <span class="n">erasure</span> <span class="n">myprofile</span>
</pre></div>
</div>
<p>或者新增一个 OSD ，这个 PG 会自动用上的。</p>
</div>
<div class="section" id="id13">
<h3>CRUSH 条件不能满足<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>即使集群拥有足够多的 OSD ， CRUSH 规则的强制要求仍有可能无法满足。假如有 10 个 OSD 分布于两个主机上，且 CRUSH 规则要求相同归置组不得使用位于同一主机的两个 OSD ，这样映射就会失败，因为只能找到两个 OSD ，你可以从规则里查看必要条件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ceph osd crush rule ls
[
    &quot;replicated_rule&quot;,
    &quot;erasurepool&quot;]
$ ceph osd crush rule dump erasurepool
{ &quot;rule_id&quot;: 1,
  &quot;rule_name&quot;: &quot;erasurepool&quot;,
  &quot;ruleset&quot;: 1,
  &quot;type&quot;: 3,
  &quot;min_size&quot;: 3,
  &quot;max_size&quot;: 20,
  &quot;steps&quot;: [
        { &quot;op&quot;: &quot;take&quot;,
          &quot;item&quot;: -1,
          &quot;item_name&quot;: &quot;default&quot;},
        { &quot;op&quot;: &quot;chooseleaf_indep&quot;,
          &quot;num&quot;: 0,
          &quot;type&quot;: &quot;host&quot;},
        { &quot;op&quot;: &quot;emit&quot;}]}
</pre></div>
</div>
<p>可以这样解决此问题，创建新存储池，其内的 PG 允许多个 OSD 位于同一主机，命令如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">erasure</span><span class="o">-</span><span class="n">code</span><span class="o">-</span><span class="n">profile</span> <span class="nb">set</span> <span class="n">myprofile</span> <span class="n">crush</span><span class="o">-</span><span class="n">failure</span><span class="o">-</span><span class="n">domain</span><span class="o">=</span><span class="n">osd</span>
<span class="n">ceph</span> <span class="n">osd</span> <span class="n">pool</span> <span class="n">create</span> <span class="n">erasurepool</span> <span class="mi">16</span> <span class="mi">16</span> <span class="n">erasure</span> <span class="n">myprofile</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h3>CRUSH 过早中止<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>假设集群拥有的 OSD 足以映射到 PG （比如有 9 个 OSD 和一个纠删码存储池的集群，每个 PG 需要 9 个 OSD ）， CRUSH 仍然有可能在找到映射前就中止了。可以这样解决：</p>
<ul class="simple">
<li><p>降低纠删存储池内 PG 的要求，让它使用较少的 OSD （需创建另一个存储池，因为纠删码配置不支持动态修改）。</p></li>
<li><p>向集群添加更多 OSD （无需修改纠删存储池，它会自动回到清洁状态）。</p></li>
<li><p>通过手工打造的 CRUSH 规则，让它多试几次以找到合适的映射。把 <code class="docutils literal notranslate"><span class="pre">set_choose_tries</span></code> 设置得高于默认值即可。</p></li>
</ul>
<p>你从集群中提取出 crushmap 之后，应该先用 <code class="docutils literal notranslate"><span class="pre">crushtool</span></code> 校验一下是否有问题，这样你的试验就无需触及 Ceph 集群，只要在一个本地文件上测试即可：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ceph osd crush rule dump erasurepool
{ &quot;rule_name&quot;: &quot;erasurepool&quot;,
  &quot;ruleset&quot;: 1,
  &quot;type&quot;: 3,
  &quot;min_size&quot;: 3,
  &quot;max_size&quot;: 20,
  &quot;steps&quot;: [
        { &quot;op&quot;: &quot;take&quot;,
          &quot;item&quot;: -1,
          &quot;item_name&quot;: &quot;default&quot;},
        { &quot;op&quot;: &quot;chooseleaf_indep&quot;,
          &quot;num&quot;: 0,
          &quot;type&quot;: &quot;host&quot;},
        { &quot;op&quot;: &quot;emit&quot;}]}
$ ceph osd getcrushmap &gt; crush.map
got crush map from osdmap epoch 13
$ crushtool -i crush.map --test --show-bad-mappings \
   --rule 1 \
   --num-rep 9 \
   --min-x 1 --max-x $((1024 * 1024))
bad mapping rule 8 x 43 num_rep 9 result [3,2,7,1,2147483647,8,5,6,0]
bad mapping rule 8 x 79 num_rep 9 result [6,0,2,1,4,7,2147483647,5,8]
bad mapping rule 8 x 173 num_rep 9 result [0,4,6,8,2,1,3,7,2147483647]
</pre></div>
</div>
<p>其中 <code class="docutils literal notranslate"><span class="pre">--num-rep</span></code> 是纠删码 CRUSH 规则所需的 OSD 数量，
<code class="docutils literal notranslate"><span class="pre">--rule</span></code> 是 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">osd</span> <span class="pre">crush</span> <span class="pre">rule</span> <span class="pre">dump</span></code> 命令结果中
<code class="docutils literal notranslate"><span class="pre">ruleset</span></code> 字段的值。此测试会尝试映射一百万个值（即
<code class="docutils literal notranslate"><span class="pre">[--min-x,--max-x]</span></code> 所指定的范围），且必须至少显示一个坏映射；如果它没有任何输出，说明所有映射都成功了，你可以就此打住：问题的根源不在这里。</p>
<p>反编译 crush 图后，你可以手动编辑其 CRUSH 规则：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ crushtool --decompile crush.map &gt; crush.txt
</pre></div>
</div>
<p>并把下面这行加进规则：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">step</span> <span class="n">set_choose_tries</span> <span class="mi">100</span>
</pre></div>
</div>
<p>然后 <code class="docutils literal notranslate"><span class="pre">crush.txt</span></code> 文件内的这部分大致如此：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule</span> <span class="n">erasurepool</span> <span class="p">{</span>
        <span class="n">ruleset</span> <span class="mi">1</span>
        <span class="nb">type</span> <span class="n">erasure</span>
        <span class="n">min_size</span> <span class="mi">3</span>
        <span class="n">max_size</span> <span class="mi">20</span>
        <span class="n">step</span> <span class="n">set_chooseleaf_tries</span> <span class="mi">5</span>
        <span class="n">step</span> <span class="n">set_choose_tries</span> <span class="mi">100</span>
        <span class="n">step</span> <span class="n">take</span> <span class="n">default</span>
        <span class="n">step</span> <span class="n">chooseleaf</span> <span class="n">indep</span> <span class="mi">0</span> <span class="nb">type</span> <span class="n">host</span>
        <span class="n">step</span> <span class="n">emit</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然后编译、并再次测试：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ crushtool --compile crush.txt -o better-crush.map
</pre></div>
</div>
<p>所有映射都成功时，用 <code class="docutils literal notranslate"><span class="pre">crushtool</span></code> 的 <code class="docutils literal notranslate"><span class="pre">--show-choose-tries</span></code>
选项能看到成功映射的尝试次数直方图：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ crushtool -i better-crush.map --test --show-bad-mappings \
   --show-choose-tries \
   --rule 1 \
   --num-rep 9 \
   --min-x 1 --max-x $((1024 * 1024))
...
11:        42
12:        44
13:        54
14:        45
15:        35
16:        34
17:        30
18:        25
19:        19
20:        22
21:        20
22:        17
23:        13
24:        16
25:        13
26:        11
27:        11
28:        13
29:        11
30:        10
31:         6
32:         5
33:        10
34:         3
35:         7
36:         5
37:         2
38:         5
39:         5
40:         2
41:         5
42:         4
43:         1
44:         2
45:         2
46:         3
47:         1
48:         0
...
102:         0
103:         1
104:         0
...
</pre></div>
</div>
<p>有 42 个归置组需 11 次重试、 44 个归置组需 12 次重试，以此类推。这样，重试的最高次数就是防止坏映射的最低值，也就是
<code class="docutils literal notranslate"><span class="pre">set_choose_tries</span></code> 的取值（即上面输出中的 103 ，因为任意归置组成功映射的重试次数都没有超过 103 ）。</p>
</div>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../start/intro/">Ceph 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/">安装 Ceph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephadm/">Cephadm</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../">Ceph 存储集群</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../configuration/">配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../deployment/">部署</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../operations/">运维</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../man/">手册页</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../">故障排除</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../community/">Ceph 社区</a></li>
<li class="toctree-l3"><a class="reference internal" href="../log-and-debug/">日志记录和调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../troubleshooting-mon/">监视器故障排除</a></li>
<li class="toctree-l3"><a class="reference internal" href="../troubleshooting-osd/">OSD 故障排除</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">归置组排障</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">归置组总不整洁</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id3">单节点集群</a></li>
<li class="toctree-l5"><a class="reference internal" href="#osd">OSD 数量小于副本数</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id4">存储池副本数为 1</a></li>
<li class="toctree-l5"><a class="reference internal" href="#crush">CRUSH 图错误</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id5">卡住的归置组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#failures-osd-peering">归置组挂了——互联失败</a></li>
<li class="toctree-l4"><a class="reference internal" href="#failures-osd-unfound">未找到的对象</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">无根归置组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">只有几个 OSD 接收数据</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">不能写入数据</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">归置组不一致</a></li>
<li class="toctree-l4"><a class="reference internal" href="#active-clean">纠删编码的归置组不是 active+clean</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id12">OSD 不够多</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id13">CRUSH 条件不能满足</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id14">CRUSH 过早中止</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../memory-profiling/">内存剖析</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cpu-profiling/">CPU 剖析</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../api/">APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephfs/">Ceph 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rbd/">Ceph 块设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../radosgw/">Ceph 对象网关</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/">Ceph 管理器守护进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/dashboard/">Ceph 仪表盘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/">API 文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/">体系结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/developer_guide/">开发者指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/internals/">Ceph 内幕</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../governance/">项目管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../foundation/">Ceph 基金会</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ceph-volume/">ceph-volume</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/general/">Ceph 版本（总目录）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/">Ceph 版本（索引）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary/">Ceph 术语</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../translation_cn/">中文版翻译资源</a></li>
</ul>


<!-- ugly kludge to make genindex look like it's part of the toc -->
<ul style="margin-top: -10px"><li class="toctree-l1"><a class="reference internal" href="../../../genindex/">Index</a></li></ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search/" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../log-and-debug/" title="日志记录和调试"
             >next</a> |</li>
        <li class="right" >
          <a href="../troubleshooting-osd/" title="OSD 故障排除"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">Ceph Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" >Ceph 存储集群</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../../operations/" >集群运维</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Ceph authors and contributors. Licensed under Creative Commons Attribution Share Alike 3.0 (CC-BY-SA-3.0).
    </div>
  </body>
</html>