
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Manually editing a CRUSH Map &#8212; Ceph Documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../_static/js/ceph.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" />
    <link rel="next" title="Adding/Removing OSDs" href="../add-or-rm-osds/" />
    <link rel="prev" title="CRUSH Maps" href="../crush-map/" />
    <script type="text/javascript" src="http://ayni.ceph.com/public/js/ceph.js"></script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../add-or-rm-osds/" title="Adding/Removing OSDs"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../crush-map/" title="CRUSH Maps"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">Ceph Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" >Ceph Storage Cluster</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../" accesskey="U">Cluster Operations</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            

<div id="dev-warning" class="admonition note" style="display:none;">
  <p class="first admonition-title">Notice</p>
  <p class="last">This document is for a development version of Ceph.</p>
</div>

<div id="eol-warning" class="admonition warning" style="display:none;">
  <p class="first admonition-title">Warning</p>
  <p class="last">This document is for an unsupported version of Ceph.</p>
</div>
  <div id="docubetter" align="right" style="display:none; padding: 15px; font-weight: bold;">
    <a id="edit-on-github" href="https://github.com/ceph/ceph/edit/master/doc/rados/operations/crush-map-edits.rst" rel="nofollow">Edit on GitHub</a> | <a href="https://github.com/ceph/ceph/projects/4">Report a Documentation Bug</a>
  </div>

  
  <div class="section" id="manually-editing-a-crush-map">
<h1>Manually editing a CRUSH Map<a class="headerlink" href="#manually-editing-a-crush-map" title="Permalink to this headline">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Manually editing the CRUSH map is considered an advanced
administrator operation.  All CRUSH changes that are
necessary for the overwhelming majority of installations are
possible via the standard ceph CLI and do not require manual
CRUSH map edits.  If you have identified a use case where
manual edits <em>are</em> necessary, consider contacting the Ceph
developers so that future versions of Ceph can make this
unnecessary.</p>
</div>
<p>To edit an existing CRUSH map:</p>
<ol class="arabic simple">
<li><a class="reference external" href="#getcrushmap">Get the CRUSH map</a>.</li>
<li><a class="reference external" href="#decompilecrushmap">Decompile</a> the CRUSH map.</li>
<li>Edit at least one of <a class="reference external" href="#crushmapdevices">Devices</a>, <a class="reference external" href="#crushmapbuckets">Buckets</a> and <a class="reference external" href="#crushmaprules">Rules</a>.</li>
<li><a class="reference external" href="#compilecrushmap">Recompile</a> the CRUSH map.</li>
<li><a class="reference external" href="#setcrushmap">Set the CRUSH map</a>.</li>
</ol>
<p>For details on setting the CRUSH map rule for a specific pool, see <a class="reference external" href="../pools#setpoolvalues">Set
Pool Values</a>.</p>
<div class="section" id="get-a-crush-map">
<span id="getcrushmap"></span><h2>Get a CRUSH Map<a class="headerlink" href="#get-a-crush-map" title="Permalink to this headline">¶</a></h2>
<p>To get the CRUSH map for your cluster, execute the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">getcrushmap</span> <span class="o">-</span><span class="n">o</span> <span class="p">{</span><span class="n">compiled</span><span class="o">-</span><span class="n">crushmap</span><span class="o">-</span><span class="n">filename</span><span class="p">}</span>
</pre></div>
</div>
<p>Ceph will output (-o) a compiled CRUSH map to the filename you specified. Since
the CRUSH map is in a compiled form, you must decompile it first before you can
edit it.</p>
</div>
<div class="section" id="decompile-a-crush-map">
<span id="decompilecrushmap"></span><h2>Decompile a CRUSH Map<a class="headerlink" href="#decompile-a-crush-map" title="Permalink to this headline">¶</a></h2>
<p>To decompile a CRUSH map, execute the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">crushtool</span> <span class="o">-</span><span class="n">d</span> <span class="p">{</span><span class="n">compiled</span><span class="o">-</span><span class="n">crushmap</span><span class="o">-</span><span class="n">filename</span><span class="p">}</span> <span class="o">-</span><span class="n">o</span> <span class="p">{</span><span class="n">decompiled</span><span class="o">-</span><span class="n">crushmap</span><span class="o">-</span><span class="n">filename</span><span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sections">
<h2>Sections<a class="headerlink" href="#sections" title="Permalink to this headline">¶</a></h2>
<p>There are six main sections to a CRUSH Map.</p>
<ol class="arabic simple">
<li><strong>tunables:</strong> The preamble at the top of the map described any <em>tunables</em>
for CRUSH behavior that vary from the historical/legacy CRUSH behavior. These
correct for old bugs, optimizations, or other changes in behavior that have
been made over the years to improve CRUSH’s behavior.</li>
<li><strong>devices:</strong> Devices are individual <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> daemons that can
store data.</li>
<li><strong>types</strong>: Bucket <code class="docutils literal notranslate"><span class="pre">types</span></code> define the types of buckets used in
your CRUSH hierarchy. Buckets consist of a hierarchical aggregation
of storage locations (e.g., rows, racks, chassis, hosts, etc.) and
their assigned weights.</li>
<li><strong>buckets:</strong> Once you define bucket types, you must define each node
in the hierarchy, its type, and which devices or other nodes it
contains.</li>
<li><strong>rules:</strong> Rules define policy about how data is distributed across
devices in the hierarchy.</li>
<li><strong>choose_args:</strong> Choose_args are alternative weights associated with
the hierarchy that have been adjusted to optimize data placement.  A single
choose_args map can be used for the entire cluster, or one can be
created for each individual pool.</li>
</ol>
</div>
<div class="section" id="crush-map-devices">
<span id="crushmapdevices"></span><h2>CRUSH Map Devices<a class="headerlink" href="#crush-map-devices" title="Permalink to this headline">¶</a></h2>
<p>Devices are individual <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> daemons that can store data.  You
will normally have one defined here for each OSD daemon in your
cluster.  Devices are identified by an id (a non-negative integer) and
a name, normally <code class="docutils literal notranslate"><span class="pre">osd.N</span></code> where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the device id.</p>
<p>Devices may also have a <em>device class</em> associated with them (e.g.,
<code class="docutils literal notranslate"><span class="pre">hdd</span></code> or <code class="docutils literal notranslate"><span class="pre">ssd</span></code>), allowing them to be conveniently targeted by a
crush rule.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># devices
device {num} {osd.name} [class {class}]
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># devices</span>
<span class="n">device</span> <span class="mi">0</span> <span class="n">osd</span><span class="o">.</span><span class="mi">0</span> <span class="k">class</span> <span class="nc">ssd</span>
<span class="n">device</span> <span class="mi">1</span> <span class="n">osd</span><span class="o">.</span><span class="mi">1</span> <span class="k">class</span> <span class="nc">hdd</span>
<span class="n">device</span> <span class="mi">2</span> <span class="n">osd</span><span class="o">.</span><span class="mi">2</span>
<span class="n">device</span> <span class="mi">3</span> <span class="n">osd</span><span class="o">.</span><span class="mi">3</span>
</pre></div>
</div>
<p>In most cases, each device maps to a single <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> daemon.  This
is normally a single storage device, a pair of devices (for example,
one for data and one for a journal or metadata), or in some cases a
small RAID device.</p>
</div>
<div class="section" id="crush-map-bucket-types">
<h2>CRUSH Map Bucket Types<a class="headerlink" href="#crush-map-bucket-types" title="Permalink to this headline">¶</a></h2>
<p>The second list in the CRUSH map defines ‘bucket’ types. Buckets facilitate
a hierarchy of nodes and leaves. Node (or non-leaf) buckets typically represent
physical locations in a hierarchy. Nodes aggregate other nodes or leaves.
Leaf buckets represent <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> daemons and their corresponding storage
media.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">The term “bucket” used in the context of CRUSH means a node in
the hierarchy, i.e. a location or a piece of physical hardware. It
is a different concept from the term “bucket” when used in the
context of RADOS Gateway APIs.</p>
</div>
<p>To add a bucket type to the CRUSH map, create a new line under your list of
bucket types. Enter <code class="docutils literal notranslate"><span class="pre">type</span></code> followed by a unique numeric ID and a bucket name.
By convention, there is one leaf bucket and it is <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">0</span></code>;  however, you may
give it any name you like (e.g., osd, disk, drive, storage, etc.):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#types</span>
<span class="nb">type</span> <span class="p">{</span><span class="n">num</span><span class="p">}</span> <span class="p">{</span><span class="n">bucket</span><span class="o">-</span><span class="n">name</span><span class="p">}</span>
</pre></div>
</div>
<p>For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># types</span>
<span class="nb">type</span> <span class="mi">0</span> <span class="n">osd</span>
<span class="nb">type</span> <span class="mi">1</span> <span class="n">host</span>
<span class="nb">type</span> <span class="mi">2</span> <span class="n">chassis</span>
<span class="nb">type</span> <span class="mi">3</span> <span class="n">rack</span>
<span class="nb">type</span> <span class="mi">4</span> <span class="n">row</span>
<span class="nb">type</span> <span class="mi">5</span> <span class="n">pdu</span>
<span class="nb">type</span> <span class="mi">6</span> <span class="n">pod</span>
<span class="nb">type</span> <span class="mi">7</span> <span class="n">room</span>
<span class="nb">type</span> <span class="mi">8</span> <span class="n">datacenter</span>
<span class="nb">type</span> <span class="mi">9</span> <span class="n">region</span>
<span class="nb">type</span> <span class="mi">10</span> <span class="n">root</span>
</pre></div>
</div>
</div>
<div class="section" id="crush-map-bucket-hierarchy">
<span id="crushmapbuckets"></span><h2>CRUSH Map Bucket Hierarchy<a class="headerlink" href="#crush-map-bucket-hierarchy" title="Permalink to this headline">¶</a></h2>
<p>The CRUSH algorithm distributes data objects among storage devices according
to a per-device weight value, approximating a uniform probability distribution.
CRUSH distributes objects and their replicas according to the hierarchical
cluster map you define. Your CRUSH map represents the available storage
devices and the logical elements that contain them.</p>
<p>To map placement groups to OSDs across failure domains, a CRUSH map defines a
hierarchical list of bucket types (i.e., under <code class="docutils literal notranslate"><span class="pre">#types</span></code> in the generated CRUSH
map). The purpose of creating a bucket hierarchy is to segregate the
leaf nodes by their failure domains, such as hosts, chassis, racks, power
distribution units, pods, rows, rooms, and data centers. With the exception of
the leaf nodes representing OSDs, the rest of the hierarchy is arbitrary, and
you may define it according to your own needs.</p>
<p>We recommend adapting your CRUSH map to your firms’s hardware naming conventions
and using instances names that reflect the physical hardware. Your naming
practice can make it easier to administer the cluster and troubleshoot
problems when an OSD and/or other hardware malfunctions and the administrator
need access to physical hardware.</p>
<p>In the following example, the bucket hierarchy has a leaf bucket named <code class="docutils literal notranslate"><span class="pre">osd</span></code>,
and two node buckets named <code class="docutils literal notranslate"><span class="pre">host</span></code> and <code class="docutils literal notranslate"><span class="pre">rack</span></code> respectively.</p>
<p class="ditaa">
<img src="../../../_images/ditaa-91dff8176c752894890e24c5e8844d0fdfb8a890.png"/>
</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The higher numbered <code class="docutils literal notranslate"><span class="pre">rack</span></code> bucket type aggregates the lower
numbered <code class="docutils literal notranslate"><span class="pre">host</span></code> bucket type.</p>
</div>
<p>Since leaf nodes reflect storage devices declared under the <code class="docutils literal notranslate"><span class="pre">#devices</span></code> list
at the beginning of the CRUSH map, you do not need to declare them as bucket
instances. The second lowest bucket type in your hierarchy usually aggregates
the devices (i.e., it’s usually the computer containing the storage media, and
uses whatever term you prefer to describe it, such as  “node”, “computer”,
“server,” “host”, “machine”, etc.). In high density environments, it is
increasingly common to see multiple hosts/nodes per chassis. You should account
for chassis failure too–e.g., the need to pull a chassis if a node fails may
result in bringing down numerous hosts/nodes and their OSDs.</p>
<p>When declaring a bucket instance, you must specify its type, give it a unique
name (string), assign it a unique ID expressed as a negative integer (optional),
specify a weight relative to the total capacity/capability of its item(s),
specify the bucket algorithm (usually <code class="docutils literal notranslate"><span class="pre">straw</span></code>), and the hash (usually <code class="docutils literal notranslate"><span class="pre">0</span></code>,
reflecting hash algorithm <code class="docutils literal notranslate"><span class="pre">rjenkins1</span></code>). A bucket may have one or more items.
The items may consist of node buckets or leaves. Items may have a weight that
reflects the relative weight of the item.</p>
<p>You may declare a node bucket with the following syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">bucket</span><span class="o">-</span><span class="nb">type</span><span class="p">]</span> <span class="p">[</span><span class="n">bucket</span><span class="o">-</span><span class="n">name</span><span class="p">]</span> <span class="p">{</span>
        <span class="nb">id</span> <span class="p">[</span><span class="n">a</span> <span class="n">unique</span> <span class="n">negative</span> <span class="n">numeric</span> <span class="n">ID</span><span class="p">]</span>
        <span class="n">weight</span> <span class="p">[</span><span class="n">the</span> <span class="n">relative</span> <span class="n">capacity</span><span class="o">/</span><span class="n">capability</span> <span class="n">of</span> <span class="n">the</span> <span class="n">item</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
        <span class="n">alg</span> <span class="p">[</span><span class="n">the</span> <span class="n">bucket</span> <span class="nb">type</span><span class="p">:</span> <span class="n">uniform</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">tree</span> <span class="o">|</span> <span class="n">straw</span> <span class="p">]</span>
        <span class="nb">hash</span> <span class="p">[</span><span class="n">the</span> <span class="nb">hash</span> <span class="nb">type</span><span class="p">:</span> <span class="mi">0</span> <span class="n">by</span> <span class="n">default</span><span class="p">]</span>
        <span class="n">item</span> <span class="p">[</span><span class="n">item</span><span class="o">-</span><span class="n">name</span><span class="p">]</span> <span class="n">weight</span> <span class="p">[</span><span class="n">weight</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For example, using the diagram above, we would define two host buckets
and one rack bucket. The OSDs are declared as items within the host buckets:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">host</span> <span class="n">node1</span> <span class="p">{</span>
        <span class="nb">id</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">alg</span> <span class="n">straw</span>
        <span class="nb">hash</span> <span class="mi">0</span>
        <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">0</span> <span class="n">weight</span> <span class="mf">1.00</span>
        <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">1</span> <span class="n">weight</span> <span class="mf">1.00</span>
<span class="p">}</span>

<span class="n">host</span> <span class="n">node2</span> <span class="p">{</span>
        <span class="nb">id</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">alg</span> <span class="n">straw</span>
        <span class="nb">hash</span> <span class="mi">0</span>
        <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">2</span> <span class="n">weight</span> <span class="mf">1.00</span>
        <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">3</span> <span class="n">weight</span> <span class="mf">1.00</span>
<span class="p">}</span>

<span class="n">rack</span> <span class="n">rack1</span> <span class="p">{</span>
        <span class="nb">id</span> <span class="o">-</span><span class="mi">3</span>
        <span class="n">alg</span> <span class="n">straw</span>
        <span class="nb">hash</span> <span class="mi">0</span>
        <span class="n">item</span> <span class="n">node1</span> <span class="n">weight</span> <span class="mf">2.00</span>
        <span class="n">item</span> <span class="n">node2</span> <span class="n">weight</span> <span class="mf">2.00</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the foregoing example, note that the rack bucket does not contain
any OSDs. Rather it contains lower level host buckets, and includes the
sum total of their weight in the item entry.</p>
</div>
<div class="topic">
<p class="topic-title first">Bucket Types</p>
<p>Ceph supports four bucket types, each representing a tradeoff between
performance and reorganization efficiency. If you are unsure of which bucket
type to use, we recommend using a <code class="docutils literal notranslate"><span class="pre">straw</span></code> bucket.  For a detailed
discussion of bucket types, refer to
<a class="reference external" href="https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf">CRUSH - Controlled, Scalable, Decentralized Placement of Replicated Data</a>,
and more specifically to <strong>Section 3.4</strong>. The bucket types are:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first"><strong>Uniform</strong>: Uniform buckets aggregate devices with <strong>exactly</strong> the same
weight. For example, when firms commission or decommission hardware, they
typically do so with many machines that have exactly the same physical
configuration (e.g., bulk purchases). When storage devices have exactly
the same weight, you may use the <code class="docutils literal notranslate"><span class="pre">uniform</span></code> bucket type, which allows
CRUSH to map replicas into uniform buckets in constant time. With
non-uniform weights, you should use another bucket algorithm.</p>
</li>
<li><p class="first"><strong>List</strong>: List buckets aggregate their content as linked lists. Based on
the <abbr title="Replication Under Scalable Hashing">RUSH</abbr> <sub>P</sub> algorithm,
a list is a natural and intuitive choice for an <strong>expanding cluster</strong>:
either an object is relocated to the newest device with some appropriate
probability, or it remains on the older devices as before. The result is
optimal data migration when items are added to the bucket. Items removed
from the middle or tail of the list, however, can result in a signiﬁcant
amount of unnecessary movement, making list buckets most suitable for
circumstances in which they <strong>never (or very rarely) shrink</strong>.</p>
</li>
<li><p class="first"><strong>Tree</strong>: Tree buckets use a binary search tree. They are more efficient
than list buckets when a bucket contains a larger set of items. Based on
the <abbr title="Replication Under Scalable Hashing">RUSH</abbr> <sub>R</sub> algorithm,
tree buckets reduce the placement time to O(log <sub>n</sub>), making them
suitable for managing much larger sets of devices or nested buckets.</p>
</li>
<li><p class="first"><strong>Straw</strong>: List and Tree buckets use a divide and conquer strategy
in a way that either gives certain items precedence (e.g., those
at the beginning of a list) or obviates the need to consider entire
subtrees of items at all. That improves the performance of the replica
placement process, but can also introduce suboptimal reorganization
behavior when the contents of a bucket change due an addition, removal,
or re-weighting of an item. The straw bucket type allows all items to
fairly “compete” against each other for replica placement through a
process analogous to a draw of straws.</p>
</li>
<li><p class="first"><strong>Straw2</strong>: Straw2 buckets improve Straw to correctly avoid any data
movement between items when neighbor weights change.</p>
<p>For example the weight of item A including adding it anew or removing
it completely, there will be data movement only to or from item A.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="topic">
<p class="topic-title first">Hash</p>
<p>Each bucket uses a hash algorithm. Currently, Ceph supports <code class="docutils literal notranslate"><span class="pre">rjenkins1</span></code>.
Enter <code class="docutils literal notranslate"><span class="pre">0</span></code> as your hash setting to select <code class="docutils literal notranslate"><span class="pre">rjenkins1</span></code>.</p>
</div>
<div class="topic" id="weightingbucketitems">
<p class="topic-title first">Weighting Bucket Items</p>
<p>Ceph expresses bucket weights as doubles, which allows for fine
weighting. A weight is the relative difference between device capacities. We
recommend using <code class="docutils literal notranslate"><span class="pre">1.00</span></code> as the relative weight for a 1TB storage device.
In such a scenario, a weight of <code class="docutils literal notranslate"><span class="pre">0.5</span></code> would represent approximately 500GB,
and a weight of <code class="docutils literal notranslate"><span class="pre">3.00</span></code> would represent approximately 3TB. Higher level
buckets have a weight that is the sum total of the leaf items aggregated by
the bucket.</p>
<p>A bucket item weight is one dimensional, but you may also calculate your
item weights to reflect the performance of the storage drive. For example,
if you have many 1TB drives where some have relatively low data transfer
rate and the others have a relatively high data transfer rate, you may
weight them differently, even though they have the same capacity (e.g.,
a weight of 0.80 for the first set of drives with lower total throughput,
and 1.20 for the second set of drives with higher total throughput).</p>
</div>
</div>
<div class="section" id="crush-map-rules">
<span id="crushmaprules"></span><h2>CRUSH Map Rules<a class="headerlink" href="#crush-map-rules" title="Permalink to this headline">¶</a></h2>
<p>CRUSH maps support the notion of ‘CRUSH rules’, which are the rules that
determine data placement for a pool. The default CRUSH map has a rule for each
pool. For large clusters, you will likely create many pools where each pool may
have its own non-default CRUSH rule.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In most cases, you will not need to modify the default rule. When
you create a new pool, by default the rule will be set to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</div>
<p>CRUSH rules define placement and replication strategies or distribution policies
that allow you to specify exactly how CRUSH places object replicas. For
example, you might create a rule selecting a pair of targets for 2-way
mirroring, another rule for selecting three targets in two different data
centers for 3-way mirroring, and yet another rule for erasure coding over six
storage devices. For a detailed discussion of CRUSH rules, refer to
<a class="reference external" href="https://ceph.com/wp-content/uploads/2016/08/weil-crush-sc06.pdf">CRUSH - Controlled, Scalable, Decentralized Placement of Replicated Data</a>,
and more specifically to <strong>Section 3.2</strong>.</p>
<p>A rule takes the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rule &lt;rulename&gt; {

        ruleset &lt;ruleset&gt;
        type [ replicated | erasure ]
        min_size &lt;min-size&gt;
        max_size &lt;max-size&gt;
        step take &lt;bucket-name&gt; [class &lt;device-class&gt;]
        step [choose|chooseleaf] [firstn|indep] &lt;N&gt; type &lt;bucket-type&gt;
        step emit
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ruleset</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">A unique whole number for identifying the rule. The name <code class="docutils literal notranslate"><span class="pre">ruleset</span></code>
is a carry-over from the past, when it was possible to have multiple
CRUSH rules per pool.</td>
</tr>
<tr class="field-even field"><th class="field-name">Purpose:</th><td class="field-body">A component of the rule mask.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-even field"><th class="field-name">Required:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">0</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">type</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Describes a rule for either a storage drive (replicated)
or a RAID.</td>
</tr>
<tr class="field-even field"><th class="field-name">Purpose:</th><td class="field-body">A component of the rule mask.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Type:</th><td class="field-body">String</td>
</tr>
<tr class="field-even field"><th class="field-name">Required:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">replicated</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Valid Values:</th><td class="field-body">Currently only <code class="docutils literal notranslate"><span class="pre">replicated</span></code> and <code class="docutils literal notranslate"><span class="pre">erasure</span></code></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">min_size</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">If a pool makes fewer replicas than this number, CRUSH will
<strong>NOT</strong> select this rule.</td>
</tr>
<tr class="field-even field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-odd field"><th class="field-name">Purpose:</th><td class="field-body">A component of the rule mask.</td>
</tr>
<tr class="field-even field"><th class="field-name">Required:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">1</span></code></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">max_size</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">If a pool makes more replicas than this number, CRUSH will
<strong>NOT</strong> select this rule.</td>
</tr>
<tr class="field-even field"><th class="field-name">Type:</th><td class="field-body">Integer</td>
</tr>
<tr class="field-odd field"><th class="field-name">Purpose:</th><td class="field-body">A component of the rule mask.</td>
</tr>
<tr class="field-even field"><th class="field-name">Required:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">10</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">take</span> <span class="pre">&lt;bucket-name&gt;</span> <span class="pre">[class</span> <span class="pre">&lt;device-class&gt;]</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Takes a bucket name, and begins iterating down the tree.
If the <code class="docutils literal notranslate"><span class="pre">device-class</span></code> is specified, it must match
a class previously used when defining a device. All
devices that do not belong to the class are excluded.</td>
</tr>
<tr class="field-even field"><th class="field-name">Purpose:</th><td class="field-body">A component of the rule.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Required:</th><td class="field-body">Yes</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">take</span> <span class="pre">data</span></code></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">choose</span> <span class="pre">firstn</span> <span class="pre">{num}</span> <span class="pre">type</span> <span class="pre">{bucket-type}</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body"><p class="first">Selects the number of buckets of the given type from within the
current bucket. The number is usually the number of replicas in
the pool (i.e., pool size).</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">{num}</span> <span class="pre">==</span> <span class="pre">0</span></code>, choose <code class="docutils literal notranslate"><span class="pre">pool-num-replicas</span></code> buckets (all available).</li>
<li>If <code class="docutils literal notranslate"><span class="pre">{num}</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">&lt;</span> <span class="pre">pool-num-replicas</span></code>, choose that many buckets.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">{num}</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, it means <code class="docutils literal notranslate"><span class="pre">pool-num-replicas</span> <span class="pre">-</span> <span class="pre">{num}</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Purpose:</th><td class="field-body"><p class="first">A component of the rule.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Prerequisite:</th><td class="field-body"><p class="first">Follows <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">take</span></code> or <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">choose</span></code>.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">choose</span> <span class="pre">firstn</span> <span class="pre">1</span> <span class="pre">type</span> <span class="pre">row</span></code></p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">chooseleaf</span> <span class="pre">firstn</span> <span class="pre">{num}</span> <span class="pre">type</span> <span class="pre">{bucket-type}</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body"><p class="first">Selects a set of buckets of <code class="docutils literal notranslate"><span class="pre">{bucket-type}</span></code> and chooses a leaf
node (that is, an OSD) from the subtree of each bucket in the set of buckets.
The number of buckets in the set is usually the number of replicas in
the pool (i.e., pool size).</p>
<ul class="simple">
<li>If <code class="docutils literal notranslate"><span class="pre">{num}</span> <span class="pre">==</span> <span class="pre">0</span></code>, choose <code class="docutils literal notranslate"><span class="pre">pool-num-replicas</span></code> buckets (all available).</li>
<li>If <code class="docutils literal notranslate"><span class="pre">{num}</span> <span class="pre">&gt;</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">&lt;</span> <span class="pre">pool-num-replicas</span></code>, choose that many buckets.</li>
<li>If <code class="docutils literal notranslate"><span class="pre">{num}</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, it means <code class="docutils literal notranslate"><span class="pre">pool-num-replicas</span> <span class="pre">-</span> <span class="pre">{num}</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Purpose:</th><td class="field-body"><p class="first">A component of the rule. Usage removes the need to select a device using two steps.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Prerequisite:</th><td class="field-body"><p class="first">Follows <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">take</span></code> or <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">choose</span></code>.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"><p class="first last"><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">chooseleaf</span> <span class="pre">firstn</span> <span class="pre">0</span> <span class="pre">type</span> <span class="pre">row</span></code></p>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">emit</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body">Outputs the current value and empties the stack. Typically used
at the end of a rule, but may also be used to pick from different
trees in the same rule.</td>
</tr>
<tr class="field-even field"><th class="field-name">Purpose:</th><td class="field-body">A component of the rule.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Prerequisite:</th><td class="field-body">Follows <code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">choose</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Example:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">step</span> <span class="pre">emit</span></code></td>
</tr>
</tbody>
</table>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">A given CRUSH rule may be assigned to multiple pools, but it
is not possible for a single pool to have multiple CRUSH rules.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">firstn</span></code> versus <code class="docutils literal notranslate"><span class="pre">indep</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Description:</th><td class="field-body"><p class="first">Controls the replacement strategy CRUSH uses when items (OSDs)
are marked down in the CRUSH map. If this rule is to be used with
replicated pools it should be <code class="docutils literal notranslate"><span class="pre">firstn</span></code> and if it’s for
erasure-coded pools it should be <code class="docutils literal notranslate"><span class="pre">indep</span></code>.</p>
<p>The reason has to do with how they behave when a
previously-selected device fails. Let’s say you have a PG stored
on OSDs 1, 2, 3, 4, 5. Then 3 goes down.</p>
<p>With the “firstn” mode, CRUSH simply adjusts its calculation to
select 1 and 2, then selects 3 but discovers it’s down, so it
retries and selects 4 and 5, and then goes on to select a new
OSD 6. So the final CRUSH mapping change is
1, 2, 3, 4, 5 -&gt; 1, 2, 4, 5, 6.</p>
<p class="last">But if you’re storing an EC pool, that means you just changed the
data mapped to OSDs 4, 5, and 6! So the “indep” mode attempts to
not do that. You can instead expect it, when it selects the failed
OSD 3, to try again and pick out 6, for a final transformation of:
1, 2, 3, 4, 5 -&gt; 1, 2, 6, 4, 5</p>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="migrating-from-a-legacy-ssd-rule-to-device-classes">
<span id="crush-reclassify"></span><h2>Migrating from a legacy SSD rule to device classes<a class="headerlink" href="#migrating-from-a-legacy-ssd-rule-to-device-classes" title="Permalink to this headline">¶</a></h2>
<p>It used to be necessary to manually edit your CRUSH map and maintain a
parallel hierarchy for each specialized device type (e.g., SSD) in order to
write rules that apply to those devices.  Since the Luminous release,
the <em>device class</em> feature has enabled this transparently.</p>
<p>However, migrating from an existing, manually customized per-device map to
the new device class rules in the trivial way will cause all data in the
system to be reshuffled.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">crushtool</span></code> has a few commands that can transform a legacy rule
and hierarchy so that you can start using the new class-based rules.
There are three types of transformations possible:</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">--reclassify-root</span> <span class="pre">&lt;root-name&gt;</span> <span class="pre">&lt;device-class&gt;</span></code></p>
<p>This will take everything in the hierarchy beneath root-name and
adjust any rules that reference that root via a <code class="docutils literal notranslate"><span class="pre">take</span>
<span class="pre">&lt;root-name&gt;</span></code> to instead <code class="docutils literal notranslate"><span class="pre">take</span> <span class="pre">&lt;root-name&gt;</span> <span class="pre">class</span> <span class="pre">&lt;device-class&gt;</span></code>.
It renumbers the buckets in such a way that the old IDs are instead
used for the specified class’s “shadow tree” so that no data
movement takes place.</p>
<p>For example, imagine you have an existing rule like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule</span> <span class="n">replicated_ruleset</span> <span class="p">{</span>
   <span class="nb">id</span> <span class="mi">0</span>
   <span class="nb">type</span> <span class="n">replicated</span>
   <span class="n">min_size</span> <span class="mi">1</span>
   <span class="n">max_size</span> <span class="mi">10</span>
   <span class="n">step</span> <span class="n">take</span> <span class="n">default</span>
   <span class="n">step</span> <span class="n">chooseleaf</span> <span class="n">firstn</span> <span class="mi">0</span> <span class="nb">type</span> <span class="n">rack</span>
   <span class="n">step</span> <span class="n">emit</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you reclassify the root <cite>default</cite> as class <cite>hdd</cite>, the rule will
become:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule</span> <span class="n">replicated_ruleset</span> <span class="p">{</span>
   <span class="nb">id</span> <span class="mi">0</span>
   <span class="nb">type</span> <span class="n">replicated</span>
   <span class="n">min_size</span> <span class="mi">1</span>
   <span class="n">max_size</span> <span class="mi">10</span>
   <span class="n">step</span> <span class="n">take</span> <span class="n">default</span> <span class="k">class</span> <span class="nc">hdd</span>
   <span class="n">step</span> <span class="n">chooseleaf</span> <span class="n">firstn</span> <span class="mi">0</span> <span class="nb">type</span> <span class="n">rack</span>
   <span class="n">step</span> <span class="n">emit</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">--set-subtree-class</span> <span class="pre">&lt;bucket-name&gt;</span> <span class="pre">&lt;device-class&gt;</span></code></p>
<p>This will mark every device in the subtree rooted at <em>bucket-name</em>
with the specified device class.</p>
<p>This is normally used in conjunction with the <code class="docutils literal notranslate"><span class="pre">--reclassify-root</span></code>
option to ensure that all devices in that root are labeled with the
correct class.  In some situations, however, some of those devices
(correctly) have a different class and we do not want to relabel
them.  In such cases, one can exclude the <code class="docutils literal notranslate"><span class="pre">--set-subtree-class</span></code>
option.  This means that the remapping process will not be perfect,
since the previous rule distributed across devices of multiple
classes but the adjusted rules will only map to devices of the
specified <em>device-class</em>, but that often is an accepted level of
data movement when the nubmer of outlier devices is small.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">--reclassify-bucket</span> <span class="pre">&lt;match-pattern&gt;</span> <span class="pre">&lt;device-class&gt;</span> <span class="pre">&lt;default-parent&gt;</span></code></p>
<p>This will allow you to merge a parallel type-specific hiearchy with the normal hierarchy.  For example, many users have maps like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">host</span> <span class="n">node1</span> <span class="p">{</span>
   <span class="nb">id</span> <span class="o">-</span><span class="mi">2</span>           <span class="c1"># do not change unnecessarily</span>
   <span class="c1"># weight 109.152</span>
   <span class="n">alg</span> <span class="n">straw</span>
   <span class="nb">hash</span> <span class="mi">0</span>  <span class="c1"># rjenkins1</span>
   <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">0</span> <span class="n">weight</span> <span class="mf">9.096</span>
   <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">1</span> <span class="n">weight</span> <span class="mf">9.096</span>
   <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">2</span> <span class="n">weight</span> <span class="mf">9.096</span>
   <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">3</span> <span class="n">weight</span> <span class="mf">9.096</span>
   <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">4</span> <span class="n">weight</span> <span class="mf">9.096</span>
   <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">5</span> <span class="n">weight</span> <span class="mf">9.096</span>
   <span class="o">...</span>
<span class="p">}</span>

<span class="n">host</span> <span class="n">node1</span><span class="o">-</span><span class="n">ssd</span> <span class="p">{</span>
   <span class="nb">id</span> <span class="o">-</span><span class="mi">10</span>          <span class="c1"># do not change unnecessarily</span>
   <span class="c1"># weight 2.000</span>
   <span class="n">alg</span> <span class="n">straw</span>
   <span class="nb">hash</span> <span class="mi">0</span>  <span class="c1"># rjenkins1</span>
   <span class="n">item</span> <span class="n">osd</span><span class="o">.</span><span class="mi">80</span> <span class="n">weight</span> <span class="mf">2.000</span>
   <span class="o">...</span>
<span class="p">}</span>

<span class="n">root</span> <span class="n">default</span> <span class="p">{</span>
   <span class="nb">id</span> <span class="o">-</span><span class="mi">1</span>           <span class="c1"># do not change unnecessarily</span>
   <span class="n">alg</span> <span class="n">straw</span>
   <span class="nb">hash</span> <span class="mi">0</span>  <span class="c1"># rjenkins1</span>
   <span class="n">item</span> <span class="n">node1</span> <span class="n">weight</span> <span class="mf">110.967</span>
   <span class="o">...</span>
<span class="p">}</span>

<span class="n">root</span> <span class="n">ssd</span> <span class="p">{</span>
   <span class="nb">id</span> <span class="o">-</span><span class="mi">18</span>          <span class="c1"># do not change unnecessarily</span>
   <span class="c1"># weight 16.000</span>
   <span class="n">alg</span> <span class="n">straw</span>
   <span class="nb">hash</span> <span class="mi">0</span>  <span class="c1"># rjenkins1</span>
   <span class="n">item</span> <span class="n">node1</span><span class="o">-</span><span class="n">ssd</span> <span class="n">weight</span> <span class="mf">2.000</span>
   <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function will reclassify each bucket that matches a
pattern.  The pattern can look like <code class="docutils literal notranslate"><span class="pre">%suffix</span></code> or <code class="docutils literal notranslate"><span class="pre">prefix%</span></code>.
For example, in the above example, we would use the pattern
<code class="docutils literal notranslate"><span class="pre">%-ssd</span></code>.  For each matched bucket, the remaining portion of the
name (that matches the <code class="docutils literal notranslate"><span class="pre">%</span></code> wildcard) specifies the <em>base bucket</em>.
All devices in the matched bucket are labeled with the specified
device class and then moved to the base bucket.  If the base bucket
does not exist (e.g., <code class="docutils literal notranslate"><span class="pre">node12-ssd</span></code> exists but <code class="docutils literal notranslate"><span class="pre">node12</span></code> does
not), then it is created and linked underneath the specified
<em>default parent</em> bucket.  In each case, we are careful to preserve
the old bucket IDs for the new shadow buckets to prevent data
movement.  Any rules with <code class="docutils literal notranslate"><span class="pre">take</span></code> steps referencing the old
buckets are adjusted.</p>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">--reclassify-bucket</span> <span class="pre">&lt;bucket-name&gt;</span> <span class="pre">&lt;device-class&gt;</span> <span class="pre">&lt;base-bucket&gt;</span></code></p>
<p>The same command can also be used without a wildcard to map a
single bucket.  For example, in the previous example, we want the
<code class="docutils literal notranslate"><span class="pre">ssd</span></code> bucket to be mapped to the <code class="docutils literal notranslate"><span class="pre">default</span></code> bucket.</p>
</li>
</ol>
<p>The final command to convert the map comprised of the above fragments would be something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ceph osd getcrushmap -o original
$ crushtool -i original --reclassify \
    --set-subtree-class default hdd \
    --reclassify-root default hdd \
    --reclassify-bucket %-ssd ssd default \
    --reclassify-bucket ssd ssd default \
    -o adjusted
</pre></div>
</div>
<p>In order to ensure that the conversion is correct, there is a <code class="docutils literal notranslate"><span class="pre">--compare</span></code> command that will test a large sample of inputs to the CRUSH map and ensure that the same result comes back out.  These inputs are controlled by the same options that apply to the <code class="docutils literal notranslate"><span class="pre">--test</span></code> command.  For the above example,:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ crushtool -i original --compare adjusted
rule 0 had 0/10240 mismatched mappings (0)
rule 1 had 0/10240 mismatched mappings (0)
maps appear equivalent
</pre></div>
</div>
<p>If there were difference, you’d see what ratio of inputs are remapped
in the parentheses.</p>
<p>If you are satisfied with the adjusted map, you can apply it to the cluster with something like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">setcrushmap</span> <span class="o">-</span><span class="n">i</span> <span class="n">adjusted</span>
</pre></div>
</div>
</div>
<div class="section" id="tuning-crush-the-hard-way">
<h2>Tuning CRUSH, the hard way<a class="headerlink" href="#tuning-crush-the-hard-way" title="Permalink to this headline">¶</a></h2>
<p>If you can ensure that all clients are running recent code, you can
adjust the tunables by extracting the CRUSH map, modifying the values,
and reinjecting it into the cluster.</p>
<ul>
<li><p class="first">Extract the latest CRUSH map:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">getcrushmap</span> <span class="o">-</span><span class="n">o</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">crush</span>
</pre></div>
</div>
</li>
<li><p class="first">Adjust tunables.  These values appear to offer the best behavior
for both large and small clusters we tested with.  You will need to
additionally specify the <code class="docutils literal notranslate"><span class="pre">--enable-unsafe-tunables</span></code> argument to
<code class="docutils literal notranslate"><span class="pre">crushtool</span></code> for this to work.  Please use this option with
extreme care.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">crushtool</span> <span class="o">-</span><span class="n">i</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">crush</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">choose</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">tries</span> <span class="mi">0</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">choose</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">fallback</span><span class="o">-</span><span class="n">tries</span> <span class="mi">0</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">choose</span><span class="o">-</span><span class="n">total</span><span class="o">-</span><span class="n">tries</span> <span class="mi">50</span> <span class="o">-</span><span class="n">o</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">crush</span><span class="o">.</span><span class="n">new</span>
</pre></div>
</div>
</li>
<li><p class="first">Reinject modified map:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">setcrushmap</span> <span class="o">-</span><span class="n">i</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">crush</span><span class="o">.</span><span class="n">new</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="legacy-values">
<h2>Legacy values<a class="headerlink" href="#legacy-values" title="Permalink to this headline">¶</a></h2>
<p>For reference, the legacy values for the CRUSH tunables can be set
with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">crushtool</span> <span class="o">-</span><span class="n">i</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">crush</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">choose</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">tries</span> <span class="mi">2</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">choose</span><span class="o">-</span><span class="n">local</span><span class="o">-</span><span class="n">fallback</span><span class="o">-</span><span class="n">tries</span> <span class="mi">5</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">choose</span><span class="o">-</span><span class="n">total</span><span class="o">-</span><span class="n">tries</span> <span class="mi">19</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">chooseleaf</span><span class="o">-</span><span class="n">descend</span><span class="o">-</span><span class="n">once</span> <span class="mi">0</span> <span class="o">--</span><span class="nb">set</span><span class="o">-</span><span class="n">chooseleaf</span><span class="o">-</span><span class="n">vary</span><span class="o">-</span><span class="n">r</span> <span class="mi">0</span> <span class="o">-</span><span class="n">o</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">crush</span><span class="o">.</span><span class="n">legacy</span>
</pre></div>
</div>
<p>Again, the special <code class="docutils literal notranslate"><span class="pre">--enable-unsafe-tunables</span></code> option is required.
Further, as noted above, be careful running old versions of the
<code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> daemon after reverting to legacy values as the feature
bit is not perfectly enforced.</p>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../start/intro/">Intro to Ceph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../start/">Installation (ceph-deploy)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/">Installation (Manual)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../start/kube-helm/">Installation (Kubernetes + Helm)</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../">Ceph Storage Cluster</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../configuration/">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../deployment/">Deployment</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../">Operations</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../operating/">Operating a Cluster</a></li>
<li class="toctree-l3"><a class="reference internal" href="../health-checks/">Health checks</a></li>
<li class="toctree-l3"><a class="reference internal" href="../monitoring/">Monitoring a Cluster</a></li>
<li class="toctree-l3"><a class="reference internal" href="../monitoring-osd-pg/">Monitoring OSDs and PGs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../user-management/">User Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pg-repair/">Repairing PG inconsistencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../data-placement/">Data Placement Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pools/">Pools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../erasure-code/">Erasure code</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cache-tiering/">Cache Tiering</a></li>
<li class="toctree-l3"><a class="reference internal" href="../placement-groups/">Placement Groups</a></li>
<li class="toctree-l3"><a class="reference internal" href="../balancer/">Balancer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../upmap/">Using the pg-upmap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crush-map/">CRUSH Maps</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Manually editing a CRUSH Map</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#get-a-crush-map">Get a CRUSH Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#decompile-a-crush-map">Decompile a CRUSH Map</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sections">Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crush-map-devices">CRUSH Map Devices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crush-map-bucket-types">CRUSH Map Bucket Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crush-map-bucket-hierarchy">CRUSH Map Bucket Hierarchy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crush-map-rules">CRUSH Map Rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#migrating-from-a-legacy-ssd-rule-to-device-classes">Migrating from a legacy SSD rule to device classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tuning-crush-the-hard-way">Tuning CRUSH, the hard way</a></li>
<li class="toctree-l4"><a class="reference internal" href="#legacy-values">Legacy values</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../add-or-rm-osds/">Adding/Removing OSDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../add-or-rm-mons/">Adding/Removing Monitors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../devices/">Device Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bluestore-migration/">BlueStore Migration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../control/">Command Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/community/">The Ceph Community</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-mon/">Troubleshooting Monitors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-osd/">Troubleshooting OSDs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-pg/">Troubleshooting PGs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/log-and-debug/">Logging and Debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/cpu-profiling/">CPU Profiling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/memory-profiling/">Memory Profiling</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../man/">Man Pages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../troubleshooting/">Troubleshooting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/">APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephfs/">Ceph Filesystem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rbd/">Ceph Block Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../radosgw/">Ceph Object Gateway</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/">Ceph Manager Daemon</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/">Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/internals/">Ceph Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../governance/">Governance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ceph-volume/">ceph-volume</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/">Ceph Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary/">Glossary</a></li>
</ul>


<!-- ugly kludge to make genindex look like it's part of the toc -->
<ul style="margin-top: -10px"><li class="toctree-l1"><a class="reference internal" href="../../../genindex/">Index</a></li></ul>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search/" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../add-or-rm-osds/" title="Adding/Removing OSDs"
             >next</a> |</li>
        <li class="right" >
          <a href="../crush-map/" title="CRUSH Maps"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">Ceph Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" >Ceph Storage Cluster</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../" >Cluster Operations</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Red Hat, Inc, and contributors. Licensed under Creative Commons Attribution Share Alike 3.0 (CC-BY-SA-3.0).
    </div>
  </body>
</html>