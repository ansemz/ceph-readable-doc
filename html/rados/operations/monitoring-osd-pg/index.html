
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>监控 OSD 和归置组 &#8212; Ceph Documentation</title>
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/js/ceph.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex/" />
    <link rel="search" title="Search" href="../../../search/" />
    <link rel="next" title="用户管理" href="../user-management/" />
    <link rel="prev" title="监控集群" href="../monitoring/" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../user-management/" title="用户管理"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../monitoring/" title="监控集群"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">Ceph Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" >Ceph 存储集群</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../" accesskey="U">集群运维</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            

<div id="dev-warning" class="admonition note" style="display:none;">
  <p class="first admonition-title">Notice</p>
  <p class="last">This document is for a development version of Ceph.</p>
</div>

<div id="eol-warning" class="admonition warning" style="display:none;">
  <p class="first admonition-title">Warning</p>
  <p class="last">This document is for an unsupported version of Ceph.</p>
</div>
  <div id="docubetter" align="right" style="display:none; padding: 15px; font-weight: bold;">
    <a id="edit-on-github" href="https://github.com/ceph/ceph/edit/master/doc/rados/operations/monitoring-osd-pg.rst" rel="nofollow">Edit on GitHub</a> | <a href="https://pad.ceph.com/p/Report_Documentation_Bugs">Report a Documentation Bug</a>
  </div>

  
  <div class="section" id="osd">
<span id="monitoring-osds-and-pgs"></span><h1>监控 OSD 和归置组<a class="headerlink" href="#osd" title="Permalink to this headline">¶</a></h1>
<p>高可用性和高可靠性要求容错方法来管理软硬件。 Ceph 没有单故障点，并且能在“降级”模式下继续提供服务。其<a class="reference external" href="../data-placement">数据归置</a>引进了一个间接层，它可保证数据不会直接绑死到某一个特定 OSD
地址，这也意味着追踪系统错误的根源得深入<a class="reference external" href="../placement-groups">归置组</a>及底层的
OSD 。</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>集群某一部分失效可能导致不能访问某个对象，但不会牵连其他对象。碰到这种问题时无需恐慌，只需按步骤检查 OSD 和归置组，然后排除故障。</p>
</div>
<p>Ceph 通常能自己康复，然而如果故障持续存在，监控 OSD 和归置组有助于找出问题所在。</p>
<div class="section" id="id1">
<h2>监控 OSD<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>某 OSD 的状态可以是在集群内（ <code class="docutils literal notranslate"><span class="pre">in</span></code> ）或集群外（ <code class="docutils literal notranslate"><span class="pre">out</span></code> ）、也可以是活着且在运行（ <code class="docutils literal notranslate"><span class="pre">up</span></code> ）或挂了且不在运行（ <code class="docutils literal notranslate"><span class="pre">down</span></code> ）。如果一个 OSD 活着，它也可以是 <code class="docutils literal notranslate"><span class="pre">in</span></code> （你可以读写数据）或者 <code class="docutils literal notranslate"><span class="pre">out</span></code> 集群。如果它以前是 <code class="docutils literal notranslate"><span class="pre">in</span></code> 但最近 <code class="docutils literal notranslate"><span class="pre">out</span></code> 了， Ceph 会把其归置组迁移到其他 OSD 。如果一 OSD <code class="docutils literal notranslate"><span class="pre">out</span></code> 了， CRUSH 就不会再分配归置组给它。如果它挂了（ <code class="docutils literal notranslate"><span class="pre">down</span></code> ）其状态也应该是 <code class="docutils literal notranslate"><span class="pre">out</span></code> 。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果一 OSD 状态为 <code class="docutils literal notranslate"><span class="pre">down</span></code> 且 <code class="docutils literal notranslate"><span class="pre">in</span></code> ，必定有问题，而且集群处于非健康状态。</p>
</div>
<p class="ditaa">
<img src="../../../_images/ditaa-abe84272aa514ed1400994f1d837e76382a8966f.png"/>
</p>
<p>如果你执行过这些命令，如 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span></code> 、 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">-s</span></code> 、或 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">-w</span></code> ，也许注意到了，集群并非一直返回 <code class="docutils literal notranslate"><span class="pre">HEALTH</span> <span class="pre">OK</span></code> ，别紧张。就 OSD 而言你应该明确，在一些情况下集群<strong>不会</strong>返回 <code class="docutils literal notranslate"><span class="pre">HEALTH</span> <span class="pre">OK</span></code> ：</p>
<ol class="arabic simple">
<li><p>你还没启动集群（它不会响应的）。</p></li>
<li><p>你刚刚启动或重启完集群，而且它还没准备好，因为归置组正被创建、 OSD 们正在相互建立连接。</p></li>
<li><p>你刚刚增加或拆除一个 OSD 。</p></li>
<li><p>你刚刚修改完集群运行图。</p></li>
</ol>
<p>OSD 监控的一个重要事情是，当集群启动并运行时，所有 OSD 也应该是启动（ <code class="docutils literal notranslate"><span class="pre">up</span></code> ）并在集群内（ <code class="docutils literal notranslate"><span class="pre">in</span></code> ）运行。用下列命令查看：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">stat</span>
</pre></div>
</div>
<p>其结果会告诉你 OSD 总数（ x ）、多少个是 <code class="docutils literal notranslate"><span class="pre">up</span></code> 的（ y ）、多少个是 <code class="docutils literal notranslate"><span class="pre">in</span></code> 的（ z ）、还有运行图的 epoch (eNNNN) 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="n">osds</span><span class="p">:</span> <span class="n">y</span> <span class="n">up</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span><span class="p">;</span> <span class="n">epoch</span><span class="p">:</span> <span class="n">eNNNN</span>
</pre></div>
</div>
<p>如果处于 <code class="docutils literal notranslate"><span class="pre">in</span></code> 状态的 OSD 多于 <code class="docutils literal notranslate"><span class="pre">up</span></code> 的，用下列命令看看哪些
<code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 守护进程没在运行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="n">tree</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#ID CLASS WEIGHT  TYPE NAME             STATUS REWEIGHT PRI-AFF</span>
 <span class="o">-</span><span class="mi">1</span>       <span class="mf">2.00000</span> <span class="n">pool</span> <span class="n">openstack</span>
 <span class="o">-</span><span class="mi">3</span>       <span class="mf">2.00000</span> <span class="n">rack</span> <span class="n">dell</span><span class="o">-</span><span class="mi">2950</span><span class="o">-</span><span class="n">rack</span><span class="o">-</span><span class="n">A</span>
 <span class="o">-</span><span class="mi">2</span>       <span class="mf">2.00000</span> <span class="n">host</span> <span class="n">dell</span><span class="o">-</span><span class="mi">2950</span><span class="o">-</span><span class="n">A1</span>
  <span class="mi">0</span>   <span class="n">ssd</span> <span class="mf">1.00000</span>      <span class="n">osd</span><span class="o">.</span><span class="mi">0</span>                <span class="n">up</span>  <span class="mf">1.00000</span> <span class="mf">1.00000</span>
  <span class="mi">1</span>   <span class="n">ssd</span> <span class="mf">1.00000</span>      <span class="n">osd</span><span class="o">.</span><span class="mi">1</span>              <span class="n">down</span>  <span class="mf">1.00000</span> <span class="mf">1.00000</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>精心设计的 CRUSH 分级结构可以帮你更快的定位到物理位置、加快故障排除。</p>
</div>
<p>若一个 OSD 状态为 <code class="docutils literal notranslate"><span class="pre">down</span></code> ，启动它：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">systemctl</span> <span class="n">start</span> <span class="n">ceph</span><span class="o">-</span><span class="n">osd</span><span class="nd">@1</span>
</pre></div>
</div>
<p>和 OSD 没运行或不启动相关的问题请看 <a class="reference external" href="../../troubleshooting/troubleshooting-osd#osd-not-running">OSD 没运行</a>。</p>
</div>
<div class="section" id="pg-sets">
<span id="id2"></span><h2>归置组集<a class="headerlink" href="#pg-sets" title="Permalink to this headline">¶</a></h2>
<p>CRUSH 要把归置组分配到 OSD 时，它先查询这个存储池的副本数设置，再把归置组分配到 OSD ，这样就把各副本分配到了不同 OSD 。比如，如果存储池要求归置组有 3 个副本， CRUSH 可能把它们分别分配到 <code class="docutils literal notranslate"><span class="pre">osd.1</span></code> 、 <code class="docutils literal notranslate"><span class="pre">osd.2</span></code> 、 <code class="docutils literal notranslate"><span class="pre">osd.3</span></code> 。考虑到你设置于 <a class="reference external" href="../crush-map">CRUSH 运行图</a>中的失败域，实际上 CRUSH 找出的是伪随机位置，所以在大型集群中，你很少能看到归置组被分配到了相邻的 OSD 。我们把涉及某个特定归置组副本的一组 OSD 称为 <strong>acting set</strong> 。在一些情况下，位于 acting set 中的一个 OSD <code class="docutils literal notranslate"><span class="pre">down</span></code> 了或者不能为归置组内的对象提供服务，这些情形发生时无需惊慌，常见原因如下：</p>
<ul class="simple">
<li><p>你增加或拆除了一 OSD 。然后 CRUSH 把那个归置组分配到了其他 OSD ，因此改变了 Acting Set 的构成、并且用 backfill 进程启动了数据迁移；</p></li>
<li><p>一 OSD <code class="docutils literal notranslate"><span class="pre">down</span></code> 了、重启了、而现在正恢复（ <code class="docutils literal notranslate"><span class="pre">recovering</span></code> ）；</p></li>
<li><p>acting set 中的一个 OSD 挂了，不能提供服务，另一个 OSD 临时接替其工作。</p></li>
</ul>
<p>Ceph 靠 <strong>up set</strong> 处理客户端请求，它们是最终处理请求的一系列 OSD 。大多数情况下 up set 和 acting set 本质上相同，如果不同，说明可能 Ceph 在迁移数据、某 OSD 在恢复、或者哪里有问题。这种情况下， Ceph 通常表现为 HEALTH WARN 状态，还有 “stuck stale” 消息。</p>
<p>用下列命令获取归置组列表：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="n">dump</span>
</pre></div>
</div>
<p>要根据指定归置组号查看哪些 OSD 位于 Acting Set 或 Up Set 里，执行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="nb">map</span> <span class="p">{</span><span class="n">pg</span><span class="o">-</span><span class="n">num</span><span class="p">}</span>
</pre></div>
</div>
<p>其结果会告诉你 osdmap 版本（ eNNN ）、归置组号（ {pg-num} ）、 Up Set 内的 OSD （ up[] ）、和 Acting Set 内的 OSD （ acting[] ）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">osdmap</span> <span class="n">eNNN</span> <span class="n">pg</span> <span class="p">{</span><span class="n">raw</span><span class="o">-</span><span class="n">pg</span><span class="o">-</span><span class="n">num</span><span class="p">}</span> <span class="p">({</span><span class="n">pg</span><span class="o">-</span><span class="n">num</span><span class="p">})</span> <span class="o">-&gt;</span> <span class="n">up</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="n">acting</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果 Up Set 和 Acting Set 不一致，这可能表明集群内部在重均衡或者有潜在问题。</p>
</div>
</div>
<div class="section" id="id3">
<h2>节点互联<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>写入数据前，归置组必须处于 <code class="docutils literal notranslate"><span class="pre">active</span></code> 、而且<strong>应该</strong>是 <code class="docutils literal notranslate"><span class="pre">clean</span></code> 状态。假设一存储池的归置组有 3 个副本，为让 Ceph 确定归置组的当前状态，一归置组的主 OSD （即 acting set 内的第一个 OSD ）会与第二和第三 OSD 建立连接、并就归置组的当前状态达成一致意见。</p>
<p class="ditaa">
<img src="../../../_images/ditaa-4cabe7c8583878eca56e9c28d1998c0a4737134c.png"/>
</p>
<p>OSD 们也向监视器报告自己的状态，详情见<a class="reference external" href="../../configuration/mon-osd-interaction/">监视器与 OSD 交互的配置</a>。要排除连接建立问题，参见<a class="reference external" href="../../troubleshooting/troubleshooting-pg#failures-osd-peering">互联失败</a>。</p>
</div>
<div class="section" id="id4">
<h2>监控归置组状态<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>如果你执行过 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">health</span></code> 、 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">-s</span></code> 、或 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">-w</span></code> 命令，你也许注意到了集群并非总返回 <code class="docutils literal notranslate"><span class="pre">HEALTH</span> <span class="pre">OK</span></code> 。检查完 OSD 是否在运行后，你还应该检查归置组状态。你应该明白，在归置组建立连接时集群<strong>不会</strong>返回 <code class="docutils literal notranslate"><span class="pre">HEALTH</span> <span class="pre">OK</span></code> ：</p>
<ol class="arabic simple">
<li><p>刚刚创建了一个存储池，归置组还没互联好；</p></li>
<li><p>归置组正在恢复；</p></li>
<li><p>刚刚增加或删除了一个 OSD ；</p></li>
<li><p>刚刚修改了 CRUSH 图，并且归置组正在迁移；</p></li>
<li><p>某一归置组的副本间的数据不一致；</p></li>
<li><p>Ceph 正在洗刷一个归置组的副本；</p></li>
<li><p>Ceph 没有足够空余容量来完成回填操作。</p></li>
</ol>
<p>如果是前述原因之一导致了 Ceph 返回 <code class="docutils literal notranslate"><span class="pre">HEALTH</span> <span class="pre">WARN</span></code> ，无需紧张。很多情况下，集群会自行恢复；有些时候你得采取些措施。归置组监控的一件重要事情是保证集群起来并运行着，所有归置组都处于 <code class="docutils literal notranslate"><span class="pre">active</span></code> 状态、并且最好是 <code class="docutils literal notranslate"><span class="pre">clean</span></code> 状态。用下列命令查看所有归置组状态：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="n">stat</span>
</pre></div>
</div>
<p>其结果会告诉你归置组总数（ x ）、有多少归置组处于某种特定状态，如 <code class="docutils literal notranslate"><span class="pre">active+clean</span></code> （ y ）、还有存储的数据量（ z ）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="n">pgs</span><span class="p">:</span> <span class="n">y</span> <span class="n">active</span><span class="o">+</span><span class="n">clean</span><span class="p">;</span> <span class="n">z</span> <span class="nb">bytes</span> <span class="n">data</span><span class="p">,</span> <span class="n">aa</span> <span class="n">MB</span> <span class="n">used</span><span class="p">,</span> <span class="n">bb</span> <span class="n">GB</span> <span class="o">/</span> <span class="n">cc</span> <span class="n">GB</span> <span class="n">avail</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>对 Ceph 来说，同时报告出归置组的多种状态是正常的。</p>
</div>
<p>除了归置组状态之外， Ceph 也会报告已用的存储容量（ aa ）、剩余空间（ bb ）和归置组总容量。这些数字在某些情况下是很重要的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- 快达到 ``near full ratio`` 或 ``full ratio`` 时；
- 由于 CRUSH 配置错误致使你的数据没能在集群内分布。
</pre></div>
</div>
<div class="topic">
<p class="topic-title">归置组唯一标识符</p>
<p>归置组 ID 由存储池号（不是存储池名字）、后面跟一个点（ . ）、然后是归置组 ID ，它是一个十六进制数字。用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">osd</span> <span class="pre">lspools</span></code> 可查看存储池号及其名字，例如，默认存储池 <code class="docutils literal notranslate"><span class="pre">rbd</span></code> 对应的存储池号是 0 。完整的归置组 ID 格式如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">pool</span><span class="o">-</span><span class="n">num</span><span class="p">}</span><span class="o">.</span><span class="p">{</span><span class="n">pg</span><span class="o">-</span><span class="nb">id</span><span class="p">}</span>
</pre></div>
</div>
<p>典型长相：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mf">0.1</span><span class="n">f</span>
</pre></div>
</div>
</div>
<p>用下列命令获取归置组列表：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="n">dump</span>
</pre></div>
</div>
<p>你也可以让它输出到 JSON 格式，并保存到文件：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="n">dump</span> <span class="o">-</span><span class="n">o</span> <span class="p">{</span><span class="n">filename</span><span class="p">}</span> <span class="o">--</span><span class="nb">format</span><span class="o">=</span><span class="n">json</span>
</pre></div>
</div>
<p>要查询某个归置组，用下列命令：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="p">{</span><span class="n">poolnum</span><span class="p">}</span><span class="o">.</span><span class="p">{</span><span class="n">pg</span><span class="o">-</span><span class="nb">id</span><span class="p">}</span> <span class="n">query</span>
</pre></div>
</div>
<p>Ceph 会输出成 JSON 格式。</p>
<p>后续子章节详述了常见的 pg 状态。</p>
<div class="section" id="id5">
<h3>存储池在建中<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>创建存储池时，它会创建指定数量的归置组。 Ceph 在创建一或多个归置组时会显示 <code class="docutils literal notranslate"><span class="pre">creating</span></code> ；创建完后，在其归置组的 Acting Set
里的 OSD 将建立互联；一旦互联完成，归置组状态应该变为
<code class="docutils literal notranslate"><span class="pre">active+clean</span></code> ，意思是 Ceph 客户端可以向归置组写入数据了。</p>
<p class="ditaa">
<img src="../../../_images/ditaa-e433528a34675610b7b9713bfbb0341e7ba56677.png"/>
</p>
</div>
<div class="section" id="id6">
<h3>互联建立中<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<p>Ceph 为归置组建立互联时，会让存储归置组副本的 OSD 之间就其中的对象和元数据状态<strong>达成一致</strong>。 Ceph 完成了互联，也就意味着存储着归置组的 OSD 就其当前状态达成了一致。然而，互联过程的完成并<strong>不能</strong>表明各副本都有了数据的最新版本。</p>
<div class="topic">
<p class="topic-title">权威历史</p>
<p>Ceph <strong>不会</strong>向客户端确认写操作，直到 acting set 里的所有
OSD 都完成了写操作。这样处理保证了从上次成功互联起， acting
set 中至少有一个成员确认了每个写操作。</p>
<p>有了各个已确认写操作的精确记录， Ceph 就可以构建和散布一个新的归置组权威历史——一个完整、完全有序的操作集，如果被采用，就能把一个 OSD 的归置组副本更新到最新。</p>
</div>
</div>
<div class="section" id="id7">
<h3>活跃<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Ceph 完成互联后，一归置组状态会变为 <code class="docutils literal notranslate"><span class="pre">active</span></code> 。 <code class="docutils literal notranslate"><span class="pre">active</span></code> 状态意味着数据已完好地保存到了主归置组和副本归置组。</p>
</div>
<div class="section" id="id8">
<h3>整洁<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>某一归置组处于 <code class="docutils literal notranslate"><span class="pre">clean</span></code> 状态时，主 OSD 和副本 OSD 已成功互联，并且没有偏离的归置组。 Ceph 已把归置组中的所有对象复制了规定份数。</p>
</div>
<div class="section" id="degraded">
<span id="id9"></span><h3>已降级<a class="headerlink" href="#degraded" title="Permalink to this headline">¶</a></h3>
<p>当客户端向主 OSD 写入数据时，由主 OSD 负责把数据副本写入其余副本 OSD 。主 OSD 把对象写入存储器后，在副本 OSD 创建完对象副本并报告给主 OSD 之前，主 OSD 会一直停留在 <code class="docutils literal notranslate"><span class="pre">degraded</span></code> 状态。</p>
<p>归置组状态可以处于 <code class="docutils literal notranslate"><span class="pre">active+degraded</span></code> 状态，原因在于一个 OSD 即使尚未持有所有对象也可以处于 <code class="docutils literal notranslate"><span class="pre">active</span></code> 状态。如果一个 OSD 挂了， Ceph 会把分配到此 OSD 的归置组都标记为 <code class="docutils literal notranslate"><span class="pre">degraded</span></code> ；那个 OSD 重生后，它们必须重新互联。然而，客户端仍可以向处于 <code class="docutils literal notranslate"><span class="pre">degraded</span></code> 状态的归置组写入新对象，只要它还在 <code class="docutils literal notranslate"><span class="pre">active</span></code> 状态。</p>
<p>如果一 OSD 挂了，且老是处于 <code class="docutils literal notranslate"><span class="pre">degraded</span></code> 状态， Ceph 会把
<code class="docutils literal notranslate"><span class="pre">down</span></code> 的 OSD 标记为在集群外（ <code class="docutils literal notranslate"><span class="pre">out</span></code> ）、并把那个 <code class="docutils literal notranslate"><span class="pre">down</span></code>
掉的 OSD 上的数据重映射到其它 OSD 。从标记为 <code class="docutils literal notranslate"><span class="pre">down</span></code> 到
<code class="docutils literal notranslate"><span class="pre">out</span></code> 的时间间隔由 <code class="docutils literal notranslate"><span class="pre">mon</span> <span class="pre">osd</span> <span class="pre">down</span> <span class="pre">out</span> <span class="pre">interval</span></code> 控制，默认是 <code class="docutils literal notranslate"><span class="pre">600</span></code> 秒。</p>
<p>归置组也会被降级（ <code class="docutils literal notranslate"><span class="pre">degraded</span></code> ），因为 Ceph 找不到本应存在于此归置组中的一或多个对象，这时，你不能读写找不到的对象，但仍能访问位于降级归置组中的其它对象。</p>
</div>
<div class="section" id="recovering">
<span id="id10"></span><h3>恢复中<a class="headerlink" href="#recovering" title="Permalink to this headline">¶</a></h3>
<p>Ceph 被设计为可容错，可抵御一定规模的软、硬件问题。当某 OSD 挂了（ <code class="docutils literal notranslate"><span class="pre">down</span></code> ）时，其内的归置组会落后于别的归置组副本；此 OSD
重生（ <code class="docutils literal notranslate"><span class="pre">up</span></code> ）时，归置组内容必须更新到当前状态；在此期间，
OSD 处于 <code class="docutils literal notranslate"><span class="pre">recovering</span></code> 状态。</p>
<p>恢复并非总是这些小事，因为一次硬件失败可能牵连多个 OSD 。比如一个机柜或房间的网络交换机失败了，这会导致多个主机上的 OSD 落后于集群的当前状态，故障恢复后每一个 OSD 都必须恢复。</p>
<p>Ceph 提供了几个选项来均衡资源竞争，如新服务请求、恢复数据对象和恢复归置组到当前状态。 <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">recovery</span> <span class="pre">delay</span> <span class="pre">start</span></code> 选项允许一 OSD 在开始恢复进程前，先重启、重建互联、甚至处理一些重放请求； <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">recovery</span> <span class="pre">thread</span> <span class="pre">timeout</span></code> 设置线程超时，因为多个 OSD
可能交替失败、重启和重建互联； <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">recovery</span> <span class="pre">max</span> <span class="pre">active</span></code> 选项限制一 OSD 最多同时接受多少请求，以防它压力过大而不能正常服务； <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">recovery</span> <span class="pre">max</span> <span class="pre">chunk</span></code> 选项限制恢复数据块尺寸，以防网络拥塞。</p>
</div>
<div class="section" id="id11">
<h3>回填中<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>有新 OSD 加入集群时， CRUSH 会把现有集群内的部分归置组重分配给它。强制新 OSD 立即接受重分配的归置组会使之过载，用归置组回填可使这个过程在后台开始。只要回填顺利完成，新 OSD 就可以对外服务了。</p>
<p>在回填运转期间，你可能见到以下几种状态之一： <code class="docutils literal notranslate"><span class="pre">backfill_wait</span></code>
表明一回填操作在等待时机，尚未开始； <code class="docutils literal notranslate"><span class="pre">backfill</span></code> 表明一回填操作正在进行； <code class="docutils literal notranslate"><span class="pre">backfill_too_full</span></code> 表明需要进行回填，但是因存储空间不足而不能完成。某归置组不能回填时，其状态应该是 <code class="docutils literal notranslate"><span class="pre">incomplete</span></code> 。</p>
<p>Ceph 有多个选项可以解决重分配归置组给一 OSD （特别是新 OSD ）时相关的负载问题。默认， <code class="docutils literal notranslate"><span class="pre">osd_max_backfills</span></code> 把双向的回填并发量都设置为 10 ； <code class="docutils literal notranslate"><span class="pre">backfill</span> <span class="pre">full</span> <span class="pre">ratio</span></code> 可让一 OSD 在接近占满率（默认 90% ）、并且用 <code class="docutils literal notranslate"><span class="pre">ceph</span> <span class="pre">osd</span> <span class="pre">set-backfillfull-ratio</span></code> 命令更改后拒绝回填请求，如果一 OSD 拒绝了回填请求，在间隔
<code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">backfill</span> <span class="pre">retry</span> <span class="pre">interval</span></code> 时间之后将重试（默认 10 秒）；
OSD 也能用 <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">backfill</span> <span class="pre">scan</span> <span class="pre">min</span></code> 和 <code class="docutils literal notranslate"><span class="pre">osd</span> <span class="pre">backfill</span> <span class="pre">scan</span> <span class="pre">max</span></code>
来管理扫描间隔（默认 64 和 512 ）。</p>
</div>
<div class="section" id="id12">
<h3>被重映射<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>负责维护某一归置组的 Acting Set 变更时，数据要从旧集合迁移到新的。新的主 OSD 要花费一些时间才能提供服务，所以老的主 OSD 还要持续提供服务、直到归置组迁移完。数据迁移完后，运行图会包含新 acting set 里的主 OSD 。</p>
</div>
<div class="section" id="id13">
<h3>发蔫<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>虽然 Ceph 用心跳来保证主机和守护进程在运行，但是 <code class="docutils literal notranslate"><span class="pre">ceph-osd</span></code> 仍有可能进入 <code class="docutils literal notranslate"><span class="pre">stuck</span></code> 状态，它们没有按时报告其状态（如网络瞬断）。默认， OSD 守护进程每半秒（ <code class="docutils literal notranslate"><span class="pre">0.5</span></code> ）会一次报告其归置组、出流量、引导和失败统计状态，此频率高于心跳阀值。如果一归置组的<strong>主 OSD</strong> 所在的 acting set 没能向监视器报告、或者其它监视器已经报告了那个主 OSD 已 <code class="docutils literal notranslate"><span class="pre">down</span></code> ，监视器们就会把此归置组标记为 <code class="docutils literal notranslate"><span class="pre">stale</span></code> 。</p>
<p>启动集群时，会经常看到 <code class="docutils literal notranslate"><span class="pre">stale</span></code> 状态，直到互联完成。集群运行一阵后，如果还能看到有归置组位于 <code class="docutils literal notranslate"><span class="pre">stale</span></code> 状态，就说明那些归置组的主 OSD 挂了（ <code class="docutils literal notranslate"><span class="pre">down</span></code> ）、或没在向监视器报告统计信息。</p>
</div>
</div>
<div class="section" id="id14">
<h2>找出故障归置组<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<p>如前所述，一个归置组状态不是 <code class="docutils literal notranslate"><span class="pre">active+clean</span></code> 时未必有问题。一般来说，归置组卡住时 Ceph 的自修复功能往往无能为力，卡住的状态细分为：</p>
<ul class="simple">
<li><p><strong>Unclean</strong>: 归置组里有些对象的副本数未达到期望次数，它们应该在恢复中；</p></li>
<li><p><strong>Inactive</strong>: 归置组不能处理读写请求，因为它们在等着一个持有最新数据的 OSD 回到 <code class="docutils literal notranslate"><span class="pre">up</span></code> 状态；</p></li>
<li><p><strong>Stale</strong>: 归置组们处于一种未知状态，因为存储它们的 OSD 有一阵子没向监视器报告了（由 <code class="docutils literal notranslate"><span class="pre">mon</span> <span class="pre">osd</span> <span class="pre">report</span> <span class="pre">timeout</span></code> 配置）。</p></li>
</ul>
<p>为找出卡住的归置组，执行：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">pg</span> <span class="n">dump_stuck</span> <span class="p">[</span><span class="n">unclean</span><span class="o">|</span><span class="n">inactive</span><span class="o">|</span><span class="n">stale</span><span class="o">|</span><span class="n">undersized</span><span class="o">|</span><span class="n">degraded</span><span class="p">]</span>
</pre></div>
</div>
<p>详情见<a class="reference external" href="../control#placement-group-subsystem">归置组子系统</a>，关于排除卡住的归置组见<a class="reference external" href="../../troubleshooting/troubleshooting-pg#troubleshooting-pg-errors">排除归置组错误</a>。</p>
</div>
<div class="section" id="id15">
<h2>定位对象<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h2>
<p>要把对象数据存入 Ceph 对象存储，一 Ceph 客户端必须：</p>
<ol class="arabic simple">
<li><p>设置对象名</p></li>
<li><p>指定一<a class="reference external" href="../pools">存储池</a></p></li>
</ol>
<p>Ceph 客户端索取最新集群运行图、并用 CRUSH 算法计算对象到<a class="reference external" href="../placement-groups">归置组</a>的映射，然后计算如何动态地把归置组映射到 OSD 。要定位对象，只需要知道对象名和存储池名字，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="nb">map</span> <span class="p">{</span><span class="n">poolname</span><span class="p">}</span> <span class="p">{</span><span class="nb">object</span><span class="o">-</span><span class="n">name</span><span class="p">}</span> <span class="p">[</span><span class="n">namespace</span><span class="p">]</span>
</pre></div>
</div>
<div class="topic">
<p class="topic-title">练习：定位一个对象</p>
<p>反正是练习，我们先创建一个对象。给 <code class="docutils literal notranslate"><span class="pre">rados</span> <span class="pre">put</span></code> 命令指定一对象名、一个包含数据的测试文件路径、和一个存储池名字，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rados</span> <span class="n">put</span> <span class="p">{</span><span class="nb">object</span><span class="o">-</span><span class="n">name</span><span class="p">}</span> <span class="p">{</span><span class="n">file</span><span class="o">-</span><span class="n">path</span><span class="p">}</span> <span class="o">--</span><span class="n">pool</span><span class="o">=</span><span class="n">data</span>
<span class="n">rados</span> <span class="n">put</span> <span class="n">test</span><span class="o">-</span><span class="nb">object</span><span class="o">-</span><span class="mi">1</span> <span class="n">testfile</span><span class="o">.</span><span class="n">txt</span> <span class="o">--</span><span class="n">pool</span><span class="o">=</span><span class="n">data</span>
</pre></div>
</div>
<p>用下列命令确认 Ceph 对象存储已经包含此对象：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rados</span> <span class="o">-</span><span class="n">p</span> <span class="n">data</span> <span class="n">ls</span>
</pre></div>
</div>
<p>现在可以定位对象了：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ceph</span> <span class="n">osd</span> <span class="nb">map</span> <span class="p">{</span><span class="n">pool</span><span class="o">-</span><span class="n">name</span><span class="p">}</span> <span class="p">{</span><span class="nb">object</span><span class="o">-</span><span class="n">name</span><span class="p">}</span>
<span class="n">ceph</span> <span class="n">osd</span> <span class="nb">map</span> <span class="n">data</span> <span class="n">test</span><span class="o">-</span><span class="nb">object</span><span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
<p>Ceph 应该输出对象的位置，例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">osdmap</span> <span class="n">e537</span> <span class="n">pool</span> <span class="s1">&#39;data&#39;</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="nb">object</span> <span class="s1">&#39;test-object-1&#39;</span> <span class="o">-&gt;</span> <span class="n">pg</span> <span class="mf">1.</span><span class="n">d1743484</span> <span class="p">(</span><span class="mf">1.4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">up</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p0</span><span class="p">)</span> <span class="n">acting</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">p0</span><span class="p">)</span>
</pre></div>
</div>
<p>要删除测试对象，用 <code class="docutils literal notranslate"><span class="pre">rados</span> <span class="pre">rm</span></code> 即可，如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rados</span> <span class="n">rm</span> <span class="n">test</span><span class="o">-</span><span class="nb">object</span><span class="o">-</span><span class="mi">1</span> <span class="o">--</span><span class="n">pool</span><span class="o">=</span><span class="n">data</span>
</pre></div>
</div>
</div>
<p>随着集群的运转，对象位置会动态改变。 Ceph 动态重均衡的优点之一，就是把你从人工迁移中解救了，详情见<a class="reference external" href="../../../architecture">体系结构</a>。</p>
</div>
</div>



          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../">
              <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../start/intro/">Ceph 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/">安装 Ceph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephadm/">Cephadm</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../">Ceph 存储集群</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../configuration/">配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../deployment/">部署</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../">运维</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../operating/">操纵集群</a></li>
<li class="toctree-l3"><a class="reference internal" href="../health-checks/">健康检查</a></li>
<li class="toctree-l3"><a class="reference internal" href="../monitoring/">监控集群</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">监控 OSD 和归置组</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">监控 OSD</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pg-sets">归置组集</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id3">节点互联</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">监控归置组状态</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#id5">存储池在建中</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id6">互联建立中</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id7">活跃</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id8">整洁</a></li>
<li class="toctree-l5"><a class="reference internal" href="#degraded">已降级</a></li>
<li class="toctree-l5"><a class="reference internal" href="#recovering">恢复中</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id11">回填中</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id12">被重映射</a></li>
<li class="toctree-l5"><a class="reference internal" href="#id13">发蔫</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#id14">找出故障归置组</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">定位对象</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../user-management/">用户管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pg-repair/">修复 PG 不一致状态</a></li>
<li class="toctree-l3"><a class="reference internal" href="../data-placement/">数据归置概览</a></li>
<li class="toctree-l3"><a class="reference internal" href="../pools/">存储池</a></li>
<li class="toctree-l3"><a class="reference internal" href="../erasure-code/">纠删码</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cache-tiering/">分级缓存</a></li>
<li class="toctree-l3"><a class="reference internal" href="../placement-groups/">归置组</a></li>
<li class="toctree-l3"><a class="reference internal" href="../balancer/">均衡器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../upmap/">使用 pg-upmap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crush-map/">CRUSH 图</a></li>
<li class="toctree-l3"><a class="reference internal" href="../crush-map-edits/">手动编辑一个 CRUSH 图</a></li>
<li class="toctree-l3"><a class="reference internal" href="../add-or-rm-osds/">增加/删除 OSD</a></li>
<li class="toctree-l3"><a class="reference internal" href="../add-or-rm-mons/">增加/删除监视器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../devices/">设备管理</a></li>
<li class="toctree-l3"><a class="reference internal" href="../bluestore-migration/">迁移到 BlueStore</a></li>
<li class="toctree-l3"><a class="reference internal" href="../control/">命令参考</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/community/">Ceph 社区</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-mon/">监视器故障排除</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-osd/">OSD 故障排除</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/troubleshooting-pg/">归置组排障</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/log-and-debug/">日志记录和调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/cpu-profiling/">CPU 剖析</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../troubleshooting/memory-profiling/">内存剖析</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../man/">手册页</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../troubleshooting/">故障排除</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api/">APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../cephfs/">Ceph 文件系统</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rbd/">Ceph 块设备</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../radosgw/">Ceph 对象网关</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/">Ceph 管理器守护进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mgr/dashboard/">Ceph 仪表盘</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/">API 文档</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architecture/">体系结构</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/developer_guide/">开发者指南</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/internals/">Ceph 内幕</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../governance/">项目管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../foundation/">Ceph 基金会</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ceph-volume/">ceph-volume</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/general/">Ceph 版本（总目录）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases/">Ceph 版本（索引）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary/">Ceph 术语</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../translation_cn/">中文版翻译资源</a></li>
</ul>


<!-- ugly kludge to make genindex look like it's part of the toc -->
<ul style="margin-top: -10px"><li class="toctree-l1"><a class="reference internal" href="../../../genindex/">Index</a></li></ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search/" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex/" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex/" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../user-management/" title="用户管理"
             >next</a> |</li>
        <li class="right" >
          <a href="../monitoring/" title="监控集群"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../">Ceph Documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../" >Ceph 存储集群</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../" >集群运维</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Ceph authors and contributors. Licensed under Creative Commons Attribution Share Alike 3.0 (CC-BY-SA-3.0).
    </div>
  </body>
</html>